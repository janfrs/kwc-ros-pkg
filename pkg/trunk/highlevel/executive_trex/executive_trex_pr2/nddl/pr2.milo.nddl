#include "pr2.declarations.nddl"
#include "pr2.rules.nddl"

float XY_ERROR = 0.25;
float THETA_ERROR = 0.1;

/**
 * Monitors battery state information
 * @see BatteryState.msg
 */
class BatteryState extends AgentTimeline {
  float rechargeThreshold;

  predicate Holds {
    float energy_remaining; // Remaining energy in Joules
    float energy_capacity; // Total energy capacity
    float power_consumption; // Power load in Watts
  }

  BatteryState(Mode _mode, float threshold){
    super(_mode, "Holds");
    rechargeThreshold = threshold;
  }
};

class WorkingStatus extends AgentTimeline {

  predicate Holds{bool recharging;}

  WorkingStatus(){
    super(Internal, "Holds");
  }
};


/**
 * A waypoint to go to
 */
class Location {
  float x;
  float y;
  float th;

  Location(float x_, float y_, float th_){
    x = x_;
    y = y_;
    th = th_;
  }
};

/**
 * The x, y, and theta values for a charging station. These describe the
 * target base pose for the robot when recharging.
 */
class ChargingStation extends Location {
  ChargingStation(float x, float y, float th){
    super(x, y, th);
  }
};

class Waypoint extends Location {
  Waypoint(float x, float y, float th){
    super(x, y, th);
  }
};

/**
 * A Navigator can navigate towards the given waypoint by repeatedly calling a lower level base controller. This pattern will allow
 * suspension and resumption of progress towards a goal if pre-empted by the need to recharge.
 */
class Navigator extends Behavior {

  predicate Active{
    Waypoint w;
  }

};

/**
 * Encapsulates the task of unplugging the robot.
 */
class RechargeController extends Behavior {

  predicate Inactive{
    bool plugIn; // If true, the robot is plugged in, otherwise not
    float x;
    float y;
    float th;
    bool desPlugIn; // If true, the robot is plugged in, otherwise not
    float desX;
    float desY;
    float desTh;
  }

  /**
   * Will have different modes based on the goal. If trying to plug in
   * then the plugIn parameter will be true and the controller will position
   * the robot and ensure it gets plugged in. If the goal is to unplug, it will
   * first enforce a wait while it achives a full charge, and then it will
   * execute commands to unplug.
   */
  predicate Active {
    bool plugIn;
    float x;
    float y;
    float th;
  }
};

/**
 * Each update is monitored and can trigger a transition to recharging
 */
BatteryState::Holds {

  bool mustRecharge;
  testLEQ(mustRecharge, energy_remaining, object.rechargeThreshold);

  // If below the threshold, transition working status to recharge
  if(mustRecharge == true){
    // at end: workingStatus.Holds.recharging == true
    any(WorkingStatus.Holds ws);
    precedes(ws.start, end);
    precedes(end, ws.end);
    eq(ws.recharging, true);
  }

  if(object.mode == Internal){
    eq(duration, 1);
    if(start == 5){
      eq(energy_remaining, 0.0);
    }
  }
}

WorkingStatus::Holds{
  // We should toggle between recharging and not recharging
  meets(Holds s);
  neq(s.recharging, recharging);

  // By default we are not recharging
  defaultOnCommit(recharging, false);

  // Do the recharging if appropriate
  if(recharging == true){
    // at start: movebase == Inactive
    any(MoveBase.Inactive mb);
    precedes(mb.start, start);
    precedes(start, mb.end);

    // Actual charging station should be selected by the planner in principle, if we were using some optimization
    // criteria. Here we select the nearest feasible charging station via a constraint. Feasibility should include access to
    // obstacle data, but it doesn't. We might want to think about generally integrating obstacle data to constrain executive choices.
    ChargingStation cs;
    nearestReachableLocation(mb.x, mb.y, cs);

    // at end: rechargeController == Inactive(false, cs.x, cs.y, cs.th)
    meets(RechargeController.Inactive rc);
    eq(rc.plugIn, false);
    eq(rc.x, cs.x);
    eq(rc.y, cs.y);
    eq(rc.th, cs.th);

    // This constraint on time is a hack to ensure the rc token falls within the planning horizon since
    // I do not have a principled mechanism for including it.
    temporalDistance(rc.start, [1 +inf], missionEnd);
  }
}

/**
 * Constrain so that the recharge controller switches between plugging on and unplugging
 */
RechargeController::Inactive{
  // By default, we are not plugged in. It may be safer to assume we are! In reality, we should
  // be able to sense this.
  defaultOnCommit(plugIn, false);

  // Bind actual values based on base state. We are only reading these values. This is an important idiom
  // to distinguish inputs evaluated from execution rather than planned for. This could be captured with suitable
  // syntax in the language to make it more explicit what is going on. All we are really doing here
  // is binding default values from execution
  // s == baseState[start]
  if(start){
    starts(BaseState.Holds bs);
    defaultOnCommit(x, bs.x);
    defaultOnCommit(y, bs.y);
    defaultOnCommit(th, bs.th);
  }

  // Preceded by an effort to get to a desired pose. This drives regression from the goal for planning
  met_by(Active p);
  eq(p.plugIn, plugIn);
  eq(p.x, x);
  eq(p.y, y);
  eq(p.th, th);

  // Require actual and desired values to be within some tolerance
  addEq(x, [-0.25, 0.25], desX);
  addEq(y, [-0.25, 0.25], desY);
  addEq(th, [-0.25, 0.25], desTh);
}

RechargeController::Active{
  // Successor desired values should match up
  meets(Inactive s);
  eq(s.desPlugIn, plugIn);
  eq(s.desX, x);
  eq(s.desY, y);
  eq(s.desTh, th);

  // Predecessor desired values must match up. The actual plug in value
  // of the predecessor should differ from the commanded plug in value
  // in this state
  met_by(Inactive p);
  neq(p.plugIn, plugIn);

  // If we are trying to unplug, then the predecessor's desired values should
  // be the same for position as these.
  if(plugIn == false){
    eq(p.desX, x);
    eq(p.desY, y);
    eq(p.desTh, th);
  }

  // When busy pluging in or unplugging, we require that we are located, and stationary, at the
  // correct charging station
  contained_by(MoveBase.Inactive mb);
  eq(mb.desX, x);
  eq(mb.desY, y);
  eq(mb.desTh, th);
}

Navigator::Active{
  // ends: moveBase == Active(w.x, w.y, w.th);
  ends(MoveBase.Active move);
  eq(move.x, w.x);
  eq(move.y, w.y);
  eq(move.th, w.th);

  // contained_by: ws == Holds(false);
  any(WorkingStatus.Holds ws);
  eq(ws.recharging, false);
  precedes(ws.start, move.start);
  precedes(move.end, ws.end);
  leq(move.duration, ws.duration);

  // Check end conditions. Note that this formulation should always be resolved in implementation
  // by binding to an existing token.
  // s == baseState(end);
  // distance(s.x, s.y, w.x, w.y) <= XY_ERROR
  if(end){
    ends(BaseState.Holds s);
    float distance;
    calcDistance(distance, s.x, s.y, w.x, w.y);
    leq(distance, XY_ERROR);
  }
}
