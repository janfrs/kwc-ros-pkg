#include "pr2.declarations.nddl"
#include "pr2.rules.nddl"

float XY_ERROR = 0.25;
float THETA_ERROR = 0.1;

/**
 * Monitors battery state information
 * @see BatteryState.msg
 */
class BatteryState extends AgentTimeline {
  float rechargeThreshold;

  predicate Holds {
    float energy_remaining; // Remaining energy in Joules
    float energy_capacity; // Total energy capacity
    float power_consumption; // Power load in Watts
  }

  BatteryState(Mode _mode, float threshold){
    super(_mode, "Holds");
    rechargeThreshold = threshold;
  }
};

/**
 * This is an abstract state variable internal to the executive which reflects if we are 
 * able to do useful work or if we should focus on recharging. Tripping this stae variable
 * into a recharging state will lock out other activities from execution until we are able to
 * finish recharging.
 */
class WorkingStatus extends AgentTimeline {

  predicate Holds{bool recharging;}

  WorkingStatus(){
    super(Internal, "Holds");
  }
};

/**
 * A waypoint to go to
 */
class Location {
  float x;
  float y;
  float th;

  Location(float x_, float y_, float th_){
    x = x_;
    y = y_;
    th = th_;
  }
};

/**
 * The x, y, and theta values for a charging station. These describe the
 * target base pose for the robot when recharging.
 */
class ChargingStation extends Location {
  ChargingStation(float x, float y, float th){
    super(x, y, th);
  }
};

class Waypoint extends Location {
  Waypoint(float x, float y, float th){
    super(x, y, th);
  }
};

/**
 * A Navigator can navigate towards the given waypoint by repeatedly calling a lower level base controller (MoveBase). This pattern will allow
 * suspension and resumption of progress towards a goal if pre-empted by the need to recharge.
 */
class Navigator extends Behavior {

  /**
   * When active, we are pursuing a waypoint, although we may be pre-empted
   */
  predicate Active{
    Waypoint w;
  }

  Navigator(){
    super(Internal, "Inactive");
  }
};

/**
 * A top level timeline that will drive navigation goals until a target iteration count is reached.
 */
class VenusDeMiles extends AgentTimeline {

  predicate Holds{
    int iterationCount; // Current iteration count
    int iterationLimit; // Iteration Limit (when done)
    Waypoint w; // Way point to achieve
  }

  VenusDeMiles(){
    super(Internal, "Holds");
  }
};

/**
 * A simple iterator pattern - drives subgoaling on the Navigator Timeline
 */
VenusDeMiles::Holds{
  defaultOnCommit(iterationCount, 0);
  defaultOnCommit(iterationLimit, 0);

  bool busy;
  testLT(busy, iterationCount, iterationLimit);
  if(busy == true){
    randomSelect(w);
    ends(Navigator.Active n);
    eq(n.w, w);

    meets(Holds s);
    addEq(iterationCount, 1, s.iterationCount);
    eq(iterationLimit, s.iterationLimit);
  }
}

/**
 * Encapsulates the task of unplugging the robot.
 */
class RechargeController extends Behavior {

  /**
   * The recharge controller has an expected pose when in an inactive state
   */
  predicate Inactive{
    float desX;
    float desY;
    float desTh;
  }

  /**
   * When active, the recharge controller takes care of any local positioning, emailingm waiting etc.,
   * until such time as the battery has been full recharged
   */
  predicate Active {
    float x;
    float y;
    float th;
  }

};

/**
 * Each update is monitored and can trigger a transition to recharging
 */
BatteryState::Holds {

  bool mustRecharge;
  testLEQ(mustRecharge, energy_remaining, object.rechargeThreshold);

  // If below the threshold, transition working status to recharge
  // if(energy_remaining < object.rechargeThreshold){
  if(mustRecharge == true){
    // workingStatus[end] == Holds(true)
    any(WorkingStatus.Holds ws);
    precedes(ws.start, end);
    precedes(end, ws.end);
    eq(ws.recharging, true);
  }

  // Ignore this - it is a hack for testing
  /*if(object.mode == Internal){
    eq(duration, 1);
    if(start == 5){
      eq(energy_remaining, 0.0);
    }
  }*/
}

WorkingStatus::Holds{
  // We should toggle between recharging and not recharging
  // this[end] == Holds(!recharging); 
  meets(Holds s);
  neq(s.recharging, recharging);

  // By default we are not recharging
  defaultOnCommit(recharging, false);

  // Do the recharging if appropriate
  if(recharging == true){
    // Reactive structure, only evaluate when started
    if(start){
      // Actual charging station should be selected by the planner in principle, if we were using some optimization
      // criteria. Here we select the nearest feasible charging station via a constraint. Feasibility should include access to
      // obstacle data, but it doesn't. We might want to think about generally integrating obstacle data to constrain executive choices.
      // bs = baseState[start];
      ChargingStation cs;
      starts(BaseState.Holds bs);
      nearestReachableLocation(bs.x, bs.y, cs);

      // rechargeController[end] == Inactive(false, cs.x, cs.y, cs.th)
      any(RechargeController.Inactive rc);
      eq(rc.desX, cs.x);
      eq(rc.desY, cs.y);
      eq(rc.desTh, cs.th);
      precedes(rc.start, end);
      precedes(end, rc.end);
    }
  }
}

/**
 * Constrain so that the recharge controller switches between plugging on and unplugging
 */
RechargeController::Inactive{
  // Preceded by an effort to get to a desired pose. This drives regression from the goal for planning
  // this[start-1] == Active(desX, desY, desTh)
  met_by(Active p);
  eq(p.x, desX);
  eq(p.y, desY);
  eq(p.th, desTh);

  // Compare values based on base state. We are only reading these values. This is an important idiom
  // to distinguish inputs evaluated from execution rather than planned for. This could be captured with suitable
  // syntax in the language to make it more explicit what is going on. All we are really doing here
  // is binding default values from execution
  // baseState[start] == Holds( desX + [-0.25, 0.25], desY + [-0.25, 0.25], desTh + [-0.25, 0.25])
  if(start){
    starts(BaseState.Holds bs);
    addEq(bs.x, [-0.25, 0.25], desX);
    addEq(bs.y, [-0.25, 0.25], desY);
    addEq(bs.th, [-0.25, 0.25], desTh);
  }
}

RechargeController::Active{
  // When busy pluging in or unplugging, we require that we are located, and stationary, at the
  // correct charging station. This is derived by the given parameters

  // contained_by: moveBase == Inactive(*, *, *, x, y, th);
  any(MoveBase.Inactive mb);
  eq(mb.desX, x);
  eq(mb.desY, y);
  eq(mb.desTh, th);
  leq(duration, mb.duration);
  precedes(mb.start, start);
  precedes(end, mb.end);
}

Navigator::Active{
  // ends: moveBase == Active(w.x, w.y, w.th);
  ends(MoveBase.Active move);
  eq(move.x, w.x);
  eq(move.y, w.y);
  eq(move.th, w.th);

  // contained_by: ws == Holds(false);
  any(WorkingStatus.Holds ws);
  eq(ws.recharging, false);
  precedes(ws.start, move.start);
  precedes(move.end, ws.end);
  leq(move.duration, ws.duration);

  // Check end conditions. Note that this formulation should always be resolved in implementation
  // by binding to an existing token.
  // s = baseState[end];
  // distance(s.x, s.y, w.x, w.y) <= XY_ERROR
  if(end){
    ends(BaseState.Holds s);
    float distance;
    calcDistance(distance, s.x, s.y, w.x, w.y);
    leq(distance, XY_ERROR);
  }
}
