#include "pr2.declarations.nddl"
#include "pr2.rules.nddl"

float XY_ERROR = 0.25;
float THETA_ERROR = 0.1;

/**
 * Monitors battery state information
 * @see BatteryState.msg
 */
class BatteryState extends AgentTimeline {
  float rechargeThreshold;

  predicate Holds {
    float energy_remaining; // Remaining energy in Joules
    float energy_capacity; // Total energy capacity
    float power_consumption; // Power load in Watts
  }

  BatteryState(Mode _mode, float threshold){
    super(_mode, "Holds");
    rechargeThreshold = threshold;
  }
};

class WorkingStatus extends AgentTimeline {

  predicate Holds{bool recharging;}

  WorkingStatus(){
    super(Internal, "Holds");
  }
};


/**
 * A waypoint to go to
 */
class Location {
  float x;
  float y;
  float th;

  Location(float x_, float y_, float th_){
    x = x_;
    y = y_;
    th = th_;
  }
};

/**
 * The x, y, and theta values for a charging station. These describe the
 * target base pose for the robot when recharging.
 */
class ChargingStation extends Location {
  ChargingStation(float x, float y, float th){
    super(x, y, th);
  }
};

class Waypoint extends Location {
  Waypoint(float x, float y, float th){
    super(x, y, th);
  }
};

/**
 * Actions used to drive execution
 */
class Actions extends AgentActions {

  /**
   * Action to drive the MoveBase controller
   */
  predicate Goto{
    Waypoint w;
  }

  /**
   * Just an event action
   */
  predicate StartEvent{}

  Actions(){
    super();
  }
};

/**
 * A Navigator can navigate towards the given waypoint by repeatedly calling a lower level base controller. This pattern will allow
 * suspension and resumption of progress towards a goal if pre-empted by the need to recharge.
 */
class Navigator extends Behavior {

  predicate Active{
    Waypoint w;
  }

};

/**
 * Encapsulates the task of unplugging the robot.
 */
class RechargeController extends Behavior {

  predicate Inactive{
    bool plugIn; // If true, the robot is plugged in, otherwise not
    float x;
    float y;
    float th;
    bool desPlugIn; // If true, the robot is plugged in, otherwise not
    float desX;
    float desY;
    float desTh;
  }

  /**
   * Will have different modes based on the goal. If trying to plug in
   * then the plugIn parameter will be true and the controller will position
   * the robot and ensure it gets plugged in. If the goal is to unplug, it will
   * first enforce a wait while it achives a full charge, and then it will
   * execute commands to unplug.
   */
  predicate Active {
    bool plugIn;
    float x;
    float y;
    float th;
  }
};

/**
 * Each update is monitored and can trigger a transition to recharging
 */
BatteryState::Holds {

  bool mustRecharge;
  testLEQ(mustRecharge, energy_remaining, object.rechargeThreshold);

  // If below the threshold, transition working status to recharge
  if(mustRecharge == true){
    // at end: workingStatus.Holds.recharging == true
    any(WorkingStatus.Holds ws);
    precedes(ws.start, end);
    precedes(end, ws.end);
    eq(ws.recharging, true);
  }

  if(object.mode == Internal){
    eq(duration, 1);
    if(start == 5){
      eq(energy_remaining, 0.0);
    }
  }
}

WorkingStatus::Holds{
  meets(Holds s);
  neq(s.recharging, recharging);

  // By default we are not recharging
  defaultOnCommit(recharging, false);

  // Do the recharging if appropriate
  if(recharging == true){
    // Should ensure that at the start we deactivate any base motion
    // at start: movebase.inactive
    any(MoveBase.Inactive mb);
    precedes(mb.start, start);
    precedes(start, mb.end);

    // Actual charging station should be selected by the planner in principle
    ChargingStation cs;
    meets(RechargeController.Inactive rc);
    eq(rc.plugIn, false);
    eq(rc.x, cs.x);
    eq(rc.y, cs.y);
    eq(rc.th, cs.th);
    temporalDistance(rc.start, [1 +inf], missionEnd);
  }
}

/**
 * Constrain so that the recharge controller switches between plugging on and unplugging
 */
RechargeController::Inactive{
  // By default, we are not plugged in. It may be safer to assume we are! In reality, we should
  // be able to sense this.
  defaultOnCommit(plugIn, false);

  // Bind actual values based on base state.
  starts(BaseState.Holds bs);
  defaultOnCommit(x, bs.x);
  defaultOnCommit(y, bs.y);
  defaultOnCommit(th, bs.th);

  // Preceded by an effort to get to a desired pose
  met_by(Active p);
  eq(p.plugIn, desPlugIn);
  eq(p.x, x);
  eq(p.y, y);
  eq(p.th, th);

  // Require actual and desired values to be within some tolerance
  addEq(x, [-0.25, 0.25], desX);
  addEq(y, [-0.25, 0.25], desY);
  addEq(th, [-0.25, 0.25], desTh);
}

RechargeController::Active{
  // Successor desired values should match up
  meets(Inactive s);
  eq(s.desPlugIn, plugIn);
  eq(s.desX, x);
  eq(s.desY, y);
  eq(s.desTh, th);

  // Predecessor desired values must match up. The actual plug in value
  // of the predecessor should differ from the commanded plug in value
  // in this state
  met_by(Inactive p);
  neq(p.plugIn, plugIn);

  // If we are trying to unplug, then the predecessor's desired values should
  // be the same for position as these
  if(plugIn == false){
    eq(p.desX, x);
    eq(p.desY, y);
    eq(p.desTh, th);
  }

  // When busy pluging in or unplugging, we require that we are located, and stationary, at the
  // correct charging station
  contained_by(MoveBase.Inactive mb);
  eq(mb.desX, x);
  eq(mb.desY, y);
  eq(mb.desTh, th);
}

Navigator::Active{
  contains(Actions.Goto goto);
  eq(goto.w, w);
  concurrent(goto.end, end);

  // We should be working while going to the target
  any(WorkingStatus.Holds ws);
  eq(ws.recharging, false);

  // Long hand for contains relation
  precedes(ws.start, goto.start);
  precedes(goto.end, ws.end);
  leq(goto.duration, ws.duration);
}

Actions::Goto{
  contains(MoveBase.Active move);
  eq(move.x, w.x);
  eq(move.y, w.y);
  eq(move.th, w.th);
  concurrent(end, move.end);

  // Check end conditions
  if(end){
    ends(BaseState.Holds s);
    float distance;
    calcDistance(distance, s.x, s.y, w.x, w.y);
    leq(distance, XY_ERROR);
  }
}

RechargeController::Active{

  /* TODO - FINISH THIS */
}

