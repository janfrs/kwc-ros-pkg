Index: gazebo-svn/player/SConscript
===================================================================
--- gazebo-svn/player/SConscript	(revision 6696)
+++ gazebo-svn/player/SConscript	(working copy)
@@ -1,7 +1,8 @@
 import os
 Import('env install_prefix staticObjs sharedObjs subdirs')
 
-parseConfigs = ['pkg-config --cflags --libs playerc++']
+parseConfigs = ['pkg-config --cflags --libs playerc++',
+                'pkg-config --cflags --libs playerc']
 
 sources = ['GazeboDriver.cc',
            'GazeboClient.cc',
Index: gazebo-svn/libgazebo/Server.cc
===================================================================
--- gazebo-svn/libgazebo/Server.cc	(revision 6696)
+++ gazebo-svn/libgazebo/Server.cc	(working copy)
@@ -38,6 +38,7 @@
 #include <sys/sem.h>
 #include <sstream>
 #include <iostream>
+#include <signal.h>
 
 #include "gazebo.h"
 
@@ -92,6 +93,42 @@
 
   std::cout << "creating " << this->filename << "\n";
 
+  // check to see if there is already a directory created.
+  struct stat astat;
+  if (stat(this->filename.c_str(), &astat) == 0) {
+    // directory already exists, check gazebo.pid to see if 
+    // another gazebo is already running.
+
+    std::string pidfn = this->filename + "/gazebo.pid";
+    
+    FILE *fp = fopen(pidfn.c_str(), "r");
+    if(fp) {
+      int pid;
+      fscanf(fp, "%d", &pid);
+      fclose(fp);
+      std::cout << "found a pid file: pid=" << pid << "\n";
+
+      if(kill(pid, 0) == 0) {
+	// a gazebo process is still alive.
+	errStream << "directory [" <<  this->filename
+		  <<  "] already exists (previous crash?)\n"
+		  << "gazebo (pid=" << pid << ") is still running.";
+	throw(errStream.str());
+      } else {
+	// the gazebo process is not alive.
+	// remove directory.
+	std::cout << "The gazebo process is not alive.\n";
+
+	// remove the existing directory.
+	std::string cmd = "rm -rf '" + this->filename + "'";
+	if(system(cmd.c_str()) != 0) {
+	  errStream << "couldn't remove directory [" <<  this->filename << "]";
+	  throw(errStream.str());
+	}
+      }
+    }
+  }
+
   // Create the directory
   if (mkdir(this->filename.c_str(), S_IRUSR | S_IWUSR | S_IXUSR) != 0)
   {
@@ -108,7 +145,17 @@
       <<  strerror(errno) << "]";
       throw(errStream.str());
     }
+
   }
+
+  // write the PID to a file
+  std::string pidfn = this->filename + "/gazebo.pid";
+    
+  FILE *fp = fopen(pidfn.c_str(), "w");
+  if(fp) {
+    fprintf(fp, "%d\n", getpid());
+    fclose(fp);
+  }
 }
 
 
@@ -120,6 +167,15 @@
 
   std::cout << "deleting " << this->filename << "\n";
 
+  // unlink the pid file
+  std::string pidfn = this->filename + "/gazebo.pid";
+  if (unlink(pidfn.c_str()) < 0)
+  {
+    std::ostringstream stream;
+    stream << "error deleting pid file: " << strerror(errno);
+    throw(stream.str());
+  }
+
   // Delete the server dir
   if (rmdir(this->filename.c_str()) != 0)
   {
Index: gazebo-svn/libgazebo/Iface.cc
===================================================================
--- gazebo-svn/libgazebo/Iface.cc	(revision 6696)
+++ gazebo-svn/libgazebo/Iface.cc	(working copy)
@@ -55,6 +55,8 @@
 GZ_REGISTER_IFACE("factory", FactoryIface);
 GZ_REGISTER_IFACE("gripper", GripperIface);
 GZ_REGISTER_IFACE("actarray", ActarrayIface);
+GZ_REGISTER_IFACE("pr2array", PR2ArrayIface);
+GZ_REGISTER_IFACE("pr2gripper", PR2GripperIface);
 GZ_REGISTER_IFACE("ptz", PTZIface);
 GZ_REGISTER_IFACE("stereocamera", StereoCameraIface);
 
Index: gazebo-svn/libgazebo/gazebo.h
===================================================================
--- gazebo-svn/libgazebo/gazebo.h	(revision 6696)
+++ gazebo-svn/libgazebo/gazebo.h	(working copy)
@@ -550,7 +550,7 @@
 
 
 /// Maximum image pixels (width x height)
-#define GAZEBO_CAMERA_MAX_IMAGE_SIZE 640 * 480 * 3
+#define GAZEBO_CAMERA_MAX_IMAGE_SIZE 1024 * 1024 * 3
 
 /// \brief Camera interface data
 class CameraData
@@ -578,6 +578,9 @@
   /// Pose of the camera
   public: Pose camera_pose;
   
+  /// Is camera stream opened?
+  public: bool opened;
+  
 };
 
 /// \brief The camera interface
@@ -596,6 +599,7 @@
           {
             Iface::Create(server,id); 
             this->data = (CameraData*)this->mMap; 
+            this->data->opened=false;
           }
 
   /// \brief Open an existing interface
@@ -605,8 +609,18 @@
           {
             Iface::Open(client,id); 
             this->data = (CameraData*)this->mMap; 
+            this->data->opened=true;
           }
 
+  /// \brief Close an existing interface
+  /// \param client Pointer to the client
+  /// \param id Id of the interface
+  public: virtual void Close()
+          {
+            Iface::Close();
+            this->data->opened=false;
+          }
+
   /// Pointer to the camera data
   public: CameraData *data;
 };
@@ -825,6 +839,9 @@
 
   /// Commaned range count
   public: int cmd_range_count;
+
+  /// is laser interface opened?
+  public: bool opened;
 };
 
 /// \brief Laser interface
@@ -843,6 +860,7 @@
           {
             Iface::Create(server,id); 
             this->data = (LaserData*)this->mMap; 
+            this->data->opened=false;
           }
 
   /// \brief Open an existing interface
@@ -852,8 +870,16 @@
           {
             Iface::Open(client,id); 
             this->data = (LaserData*)this->mMap; 
+            this->data->opened=true;
           }
 
+  /// \brief Close an existing interface
+  public: virtual void Close()
+          {
+            Iface::Close();
+            this->data->opened=false;
+          }
+
   /// Pointer to the laser data
   public: LaserData *data;
 };
@@ -1057,6 +1083,30 @@
 
   /// Lift down flag
   public: int lift_down;
+
+  /// Enable flag
+  public: int cmdEnableMotor;
+
+  /// Gripper Position Rate Command
+  public: float cmdPositionRate;
+  /// Gripper Force Command
+  public: float cmdForce;
+  /// Gripper Gap Command
+  public: float cmdGap;
+
+  /// Gripper force
+  public: double gripperForce;
+  /// Gripper controller gains
+  public: double pGain;
+  public: double dGain;
+  public: double iGain;
+
+  /// Position
+  public: float actualFingerPosition[2];
+  /// Position Rate
+  public: float actualFingerPositionRate[2];
+
+
 };
 
 /// \brief Gripper interface
@@ -1254,9 +1304,327 @@
 /// \} */
 
 
+
+
 /***************************************************************************/
 /// \addtogroup libgazebo_iface
 /// \{
+/** \defgroup gripper_iface gripper
+
+  \brief PR2 Gripper interface
+
+The gripper interface allows control of a simple pseudo-1-DOF PR2 gripper, such as
+that found on the Pioneer series robots.
+
+
+\{
+*/
+
+/** Gripper state: open */
+#define GAZEBO_PR2GRIPPER_STATE_OPEN 1
+/** Gripper state: closed */
+#define GAZEBO_PR2GRIPPER_STATE_CLOSED 2
+/** Gripper state: moving */
+#define GAZEBO_PR2GRIPPER_STATE_MOVING 3
+/** Gripper state: error */
+#define GAZEBO_PR2GRIPPER_STATE_ERROR 4
+
+/** Gripper command: open */
+#define GAZEBO_PR2GRIPPER_CMD_OPEN 1
+/** Gripper command: close */
+#define GAZEBO_PR2GRIPPER_CMD_CLOSE 2
+/** Gripper command: stop */
+#define GAZEBO_PR2GRIPPER_CMD_STOP 3
+/** Gripper command: store */
+#define GAZEBO_PR2GRIPPER_CMD_STORE 4
+/** Gripper command: retrieve */
+#define GAZEBO_PR2GRIPPER_CMD_RETRIEVE 5
+
+
+/// \brief Fudicial interface data
+class PR2GripperData
+{
+  public: GazeboData head;
+
+  /// \brief Current command for the gripper
+  public: int cmd;
+
+  /// Current state of the gripper
+  public: int state;
+
+  /// Gripped limit reached flag
+  public: int grip_limit_reach;
+
+  /// Lift limit reached flag
+  public: int lift_limit_reach;
+
+  /// Outer beam obstruct flag
+  public: int outer_beam_obstruct;
+
+  /// control mode, TODO: yet to be defined
+  public: int controlMode;
+
+  /// Inner beam obstructed flag
+  public: int inner_beam_obstruct;
+
+  /// Left paddle open flag
+  public: int left_paddle_open;
+
+  /// Right paddle open flag
+  public: int right_paddle_open;
+
+  /// Lift up flag
+  public: int lift_up;
+
+  /// Lift down flag
+  public: int lift_down;
+
+  /// Enable flag
+  public: int cmdEnableMotor;
+
+  /// Gripper Position Rate Command
+  public: float cmdPositionRate;
+  /// Gripper Force Command
+  public: float cmdForce;
+  /// Gripper Gap Command
+  public: float cmdGap;
+
+  /// Gripper force
+  public: double gripperForce;
+  /// Gripper controller gains
+  public: double pGain;
+  public: double dGain;
+  public: double iGain;
+
+  /// Position
+  public: float actualFingerPosition[2];
+  /// Position Rate
+  public: float actualFingerPositionRate[2];
+
+
+};
+
+/// \brief Gripper interface
+class PR2GripperIface : public Iface
+{
+  /// \brief Constructor
+  public: PR2GripperIface():Iface("pr2gripper", sizeof(PR2GripperIface)+sizeof(PR2GripperData)) {}
+
+  /// \brief Destructor
+  public: virtual ~PR2GripperIface() {this->data = NULL;}
+
+  /// \brief Create the server
+  public: virtual void Create(Server *server, std::string id)
+          {
+            Iface::Create(server,id); 
+            this->data = (PR2GripperData*)this->mMap; 
+          }
+
+  /// \brief Open the iface 
+  public: virtual void Open(Client *client, std::string id)
+          {
+            Iface::Open(client,id); 
+            this->data = (PR2GripperData*)this->mMap; 
+          }
+
+  /// Pointer to the gripper data
+  public: PR2GripperData *data;
+};
+
+/** \} */
+/// \}
+
+
+/***************************************************************************/
+/// \addtogroup libgazebo_iface 
+/// \{
+/** \defgroup pr2array_iface actarray
+
+  \brief PR2 Array
+
+The PR2 array interface allows a user to control a set of actuators.
+
+\{
+*/
+
+/// maximum number of actuators 
+#define GAZEBO_PR2ARRAY_MAX_NUM_ACTUATORS 64
+#define GAZEBO_PR2ARRAY_JOINT_POSITION_MODE 0
+#define GAZEBO_PR2ARRAY_JOINT_SPEED_MODE 1
+#define GAZEBO_PR2ARRAY_JOINT_CURRENT_MODE 2
+
+//Actuator states
+/// Idle state
+#define GAZEBO_PR2ARRAY_ACTSTATE_IDLE     1
+
+/// Moving state 
+#define GAZEBO_PR2ARRAY_ACTSTATE_MOVING   2
+
+/// Braked state 
+#define GAZEBO_PR2ARRAY_ACTSTATE_BRAKED   3
+
+/// Stalled state 
+#define GAZEBO_PR2ARRAY_ACTSTATE_STALLED  4
+
+/// Linear type 
+#define GAZEBO_PR2ARRAY_TYPE_LINEAR       1
+/// Rotary type
+#define GAZEBO_PR2ARRAY_TYPE_ROTARY       2
+
+/// Request subtype: power 
+#define GAZEBO_PR2ARRAY_POWER_REQ         1
+/// Request subtype: brakes 
+#define GAZEBO_PR2ARRAY_BRAKES_REQ        2
+/// Request subtype: get geometry 
+#define GAZEBO_PR2ARRAY_GET_GEOM_REQ      3
+/// Request subtype: speed
+#define GAZEBO_PR2ARRAY_SPEED_REQ         4
+
+/// Command subtype: position 
+#define GAZEBO_PR2ARRAY_POS_CMD           1
+/// Command subtype: speed 
+#define GAZEBO_PR2ARRAY_SPEED_CMD         2
+/// Command subtype: home 
+#define GAZEBO_PR2ARRAY_HOME_CMD          3
+
+
+/// \brief Actuator geometry 
+class PR2ArrayActuatorGeom
+{
+
+/// Data subtype: state
+#define GAZEBO_PR2ARRAY_DATA_STATE        1
+
+
+  /// The type of the actuator - linear or rotary.
+  public: uint8_t type;
+
+  /// Min range of motion (m or rad depending on the type)
+  public: float min;
+
+  /// Center position (m or rad)
+  public: float center;
+
+  /// Max range of motion (m or rad depending on the type)
+  public: float max;
+
+  /// Home position (m or rad depending on the type)
+  public: float home;
+
+  /// The configured speed - different from current speed. 
+  public: float config_speed;
+
+  /// The maximum achievable speed of the actuator.
+  public: float max_speed;
+
+  /// If the actuator has brakes or not. 
+  public: uint8_t hasbrakes;
+};
+
+/// \brief Structure containing a single actuator's information 
+class PR2ArrayActuator
+{
+  /// The position of the actuator in m or rad depending on the type.
+  public: float actualPosition;
+  /// The speed of the actuator in m/s or rad/s depending on the type. 
+  public: float actualSpeed;
+  /// The current state of the actuator. 
+  public: uint8_t state;
+}; 
+
+  typedef struct
+   {
+      double timestamp;
+      double actualPosition;
+      double actualSpeed;
+      double actualEffectorForce;
+
+      int controlMode;
+      int jointType;
+
+      double cmdPosition;
+      double cmdSpeed;
+      double cmdEffectorForce;
+
+      int cmdEnableMotor;
+
+      double pGain;
+      double iGain;
+      double dGain;
+      double iClamp;
+      double saturationTorque;
+   } JointData;
+
+/// \brief The actuator array data packet. 
+class PR2ArrayData
+{
+  public: GazeboData head;
+
+  /// The number of actuators in the array. 
+  public: unsigned int actuators_count;
+  
+  /// The actuator data. 
+//  public: PR2ArrayActuator actuators[GAZEBO_PR2ARRAY_MAX_NUM_ACTUATORS];
+    public: JointData actuators[GAZEBO_PR2ARRAY_MAX_NUM_ACTUATORS];
+  
+  /// The actuators geoms 
+  public: PR2ArrayActuatorGeom actuator_geoms[GAZEBO_PR2ARRAY_MAX_NUM_ACTUATORS];
+  
+  /// position commands
+  public: float cmd_pos[GAZEBO_PR2ARRAY_MAX_NUM_ACTUATORS];
+  
+  /// speed commands
+  public: float cmd_speed[GAZEBO_PR2ARRAY_MAX_NUM_ACTUATORS];
+  
+  /// bad command flag - (speed to high set for the actuators or position not reachable)
+  public: int bad_cmd;
+
+  /// True if new command
+  public: bool new_cmd;
+  
+  /// position / speed comand
+  public: unsigned int joint_mode[GAZEBO_PR2ARRAY_MAX_NUM_ACTUATORS];
+  
+};
+
+/// \brief The PR2Array interface
+class PR2ArrayIface : public Iface
+{
+  /// \brief Create an interface
+  public: PR2ArrayIface():Iface("pr2array", sizeof(PR2ArrayIface)+sizeof(PR2ArrayData)) {}
+
+  /// \brief Destroy and Interface
+  public: virtual ~PR2ArrayIface() {this->data = NULL;}
+
+  /// \brief Create the interface (used by Gazebo server)
+  /// \param server Pointer to the server
+  /// \param id Id of the interface
+  public: virtual void Create(Server *server, std::string id)
+          {
+           Iface::Create(server,id); 
+           this->data = (PR2ArrayData*)this->mMap; 
+          }
+
+  /// \brief Open an existing interface
+  /// \param client Pointer to the client
+  /// \param id Id of the interface
+  public: virtual void Open(Client *client, std::string id)
+          {
+            Iface::Open(client,id); 
+            this->data = (PR2ArrayData*)this->mMap; 
+          }
+
+  /// Pointer to the act array data
+  public: PR2ArrayData *data;
+};
+
+/** \} */
+/// \} */
+
+
+/***************************************************************************/
+/// \addtogroup libgazebo_iface
+/// \{
 /** \defgroup ptz_iface ptz
 
   \brief PTZ interface
@@ -1334,7 +1702,7 @@
 \{
 */
 
-#define GAZEBO_STEREO_CAMERA_MAX_RGB_SIZE 640 * 480 * 3
+#define GAZEBO_STEREO_CAMERA_MAX_RGB_SIZE 640 * 480 * 9
 #define GAZEBO_STEREO_CAMERA_MAX_DISPARITY_SIZE 640 * 480
 
 /// \brief Stereo data
@@ -1384,6 +1752,9 @@
   /// Right disparity (float)
   public: float right_disparity[GAZEBO_STEREO_CAMERA_MAX_DISPARITY_SIZE];
 
+  /// Is camera stream opened?
+  public: bool opened;
+  
 }; 
 
 
@@ -1401,6 +1772,7 @@
           {
             Iface::Create(server,id); 
             this->data = (StereoCameraData*)this->mMap; 
+            this->data->opened=false;
           }
 
   /// \brief Open the iface 
@@ -1408,8 +1780,16 @@
           {
             Iface::Open(client,id); 
             this->data = (StereoCameraData*)this->mMap; 
+            this->data->opened=true;
           }
 
+  /// \brief Close the iface 
+  public: virtual void Close()
+          {
+            Iface::Close();
+            this->data->opened=false;
+          }
+
   /// Pointer to the stereo data
   public: StereoCameraData *data;
 };
Index: gazebo-svn/server/physics/SphereGeom.cc
===================================================================
--- gazebo-svn/server/physics/SphereGeom.cc	(revision 6696)
+++ gazebo-svn/server/physics/SphereGeom.cc	(working copy)
@@ -56,7 +56,11 @@
   dMassSetSphereTotal(&this->mass, this->dblMass, radius);
 
   // Create the sphere geometry
-  this->SetGeom(dCreateSphere(0, radius ), true);
+  if (this->massMatrix)
+    dMassSetParameters(&this->mass, this->dblMass, this->cx, this->cy, this->cz,
+                       this->ixx,this->iyy,this->izz,this->ixy,this->ixz,this->iyz);
+  else
+    this->SetGeom(dCreateSphere(0, radius ), true);
 
   //to be able to show physics
   /*  this->visualNode->AttachMesh("unit_sphere"); // unit_sphere radius=1 diameter=2
Index: gazebo-svn/server/physics/BoxGeom.cc
===================================================================
--- gazebo-svn/server/physics/BoxGeom.cc	(revision 6696)
+++ gazebo-svn/server/physics/BoxGeom.cc	(working copy)
@@ -55,7 +55,13 @@
   size = node->GetVector3("size",Vector3(1,1,1));
 
   // Initialize box mass matrix
-  dMassSetBoxTotal(&this->mass, this->dblMass, size.x, size.y, size.z);
+  // set mass matrix if user provides some info
+  // pending a tag <massMatrix>true</massMatrix> in geom:
+  if (this->massMatrix)
+    dMassSetParameters(&this->mass, this->dblMass, this->cx, this->cy, this->cz,
+                       this->ixx,this->iyy,this->izz,this->ixy,this->ixz,this->iyz);
+  else
+    dMassSetBoxTotal(&this->mass, this->dblMass, size.x, size.y, size.z);
 
   // Create a box geometry with box mass matrix
   this->SetGeom(dCreateBox( 0, size.x, size.y, size.z), true );
Index: gazebo-svn/server/physics/Geom.hh
===================================================================
--- gazebo-svn/server/physics/Geom.hh	(revision 6696)
+++ gazebo-svn/server/physics/Geom.hh	(working copy)
@@ -170,6 +170,10 @@
     ///  Mass as a double
     protected: double dblMass;
 
+    ///  User specified Mass Matrix
+    protected: bool massMatrix;
+    protected: double cx,cy,cz,ixx,iyy,izz,ixy,ixz,iyz;
+
     /// Special bounding box visual
     private: OgreVisual *bbVisual;
 
Index: gazebo-svn/server/physics/CylinderGeom.cc
===================================================================
--- gazebo-svn/server/physics/CylinderGeom.cc	(revision 6696)
+++ gazebo-svn/server/physics/CylinderGeom.cc	(working copy)
@@ -51,7 +51,12 @@
   double length = node->GetTupleDouble("size",1,1.0);
 
   // Initialize mass matrix
-  dMassSetCylinderTotal(&this->mass, this->dblMass, 3, radius, length);
+  // pending a tag <massMatrix>true</massMatrix> in geom:
+  if (this->massMatrix)
+    dMassSetParameters(&this->mass, this->dblMass, this->cx, this->cy, this->cz,
+                       this->ixx,this->iyy,this->izz,this->ixy,this->ixz,this->iyz);
+  else
+    dMassSetCylinderTotal(&this->mass, this->dblMass, 3, radius, length);
 
   this->SetGeom( dCreateCylinder( 0, radius, length ), true );
 
Index: gazebo-svn/server/physics/Geom.cc
===================================================================
--- gazebo-svn/server/physics/Geom.cc	(revision 6696)
+++ gazebo-svn/server/physics/Geom.cc	(working copy)
@@ -102,6 +102,21 @@
     this->dblMass = 0.001;
   }
 
+  // option to enter full maxx matrix
+  std::string tmpMassMatrix = node->GetString("massMatrix","false",0);
+  if (tmpMassMatrix == "true") this->massMatrix = true;
+  else                         this->massMatrix = false;
+  this->cx = node->GetDouble("cx",0.0,0);
+  this->cy = node->GetDouble("cy",0.0,0);
+  this->cz = node->GetDouble("cz",0.0,0);
+  this->ixx = node->GetDouble("ixx",0.001,0);
+  this->iyy = node->GetDouble("iyy",0.001,0);
+  this->izz = node->GetDouble("izz",0.001,0);
+  this->ixy = node->GetDouble("ixy",0.001,0);
+  this->ixz = node->GetDouble("ixz",0.001,0);
+  this->iyz = node->GetDouble("iyz",0.001,0);
+
+
   this->contact->Load(node);
 
   this->LoadChild(node);
@@ -398,18 +413,21 @@
   if (!this->placeable)
     return NULL;
 
-  pose = this->GetPose();
+  pose = this->GetPose(); // get pose of the geometry
 
   q[0] = pose.rot.u;
   q[1] = pose.rot.x;
   q[2] = pose.rot.y;
   q[3] = pose.rot.z;
 
-  dQtoR(q,r);
+  dQtoR(q,r); // turn quaternion into rotation matrix
 
 
+  // this->mass was init to zero at start,
+  // read user specified mass into this->dblMass and dMassAdd in this->mass
   this->bodyMass = this->mass;
 
+
   if (dMassCheck(&this->bodyMass))
   {
     dMassRotate(&this->bodyMass, r);
Index: gazebo-svn/server/physics/HingeJoint.cc
===================================================================
--- gazebo-svn/server/physics/HingeJoint.cc	(revision 6696)
+++ gazebo-svn/server/physics/HingeJoint.cc	(working copy)
@@ -38,6 +38,7 @@
     : Joint()
 {
   this->jointId = dJointCreateHinge( worldId, NULL );
+  this->type = Joint::HINGE;
 }
 
 
Index: gazebo-svn/server/physics/ode/ODEPhysics.cc
===================================================================
--- gazebo-svn/server/physics/ode/ODEPhysics.cc	(revision 6696)
+++ gazebo-svn/server/physics/ode/ODEPhysics.cc	(working copy)
@@ -266,13 +266,12 @@
         // Compute the CFM and ERP by assuming the two bodies form a
         // spring-damper system.
         h = self->stepTime;
-        kp = 1 / (1 / geom1->contact->kp + 1 / geom2->contact->kp);
+        kp = 1.0 / (1.0 / geom1->contact->kp + 1.0 / geom2->contact->kp);
         kd = geom1->contact->kd + geom2->contact->kd;
         contact.surface.mode |= dContactSoftERP | dContactSoftCFM;
         contact.surface.soft_erp = h * kp / (h * kp + kd);
-        contact.surface.soft_cfm = 1 / (h * kp + kd);
+        contact.surface.soft_cfm = 1.0 / (h * kp + kd);
 
-
         //contacts[i].surface.mode |= dContactBounce | dContactSoftCFM;
         contact.surface.mode |= dContactApprox1;
         contact.surface.mu = MIN(geom1->contact->mu1, geom2->contact->mu1);
Index: gazebo-svn/server/physics/TrimeshGeom.cc
===================================================================
--- gazebo-svn/server/physics/TrimeshGeom.cc	(revision 6696)
+++ gazebo-svn/server/physics/TrimeshGeom.cc	(working copy)
@@ -208,7 +208,11 @@
 
   this->geomId = dCreateTriMesh( this->spaceId, this->odeData,0,0,0 );
 
-  dMassSetTrimesh(&this->mass, this->dblMass, this->geomId);
+  if (this->massMatrix)
+    dMassSetParameters(&this->mass, this->dblMass, this->cx, this->cy, this->cz,
+                       this->ixx,this->iyy,this->izz,this->ixy,this->ixz,this->iyz);
+  else
+    dMassSetTrimesh(&this->mass, this->dblMass, this->geomId);
 
   // Create the trimesh geometry
   this->SetGeom(this->geomId, true);
Index: gazebo-svn/server/physics/SliderJoint.cc
===================================================================
--- gazebo-svn/server/physics/SliderJoint.cc	(revision 6696)
+++ gazebo-svn/server/physics/SliderJoint.cc	(working copy)
@@ -35,6 +35,8 @@
     : Joint()
 {
   this->jointId = dJointCreateSlider( worldId, NULL );
+  this->type = Joint::SLIDER;
+  fprintf(stderr," slider jointId %d\n",this->jointId);
 }
 
 
Index: gazebo-svn/server/sensors/Sensor.hh
===================================================================
--- gazebo-svn/server/sensors/Sensor.hh	(revision 6696)
+++ gazebo-svn/server/sensors/Sensor.hh	(working copy)
@@ -63,6 +63,7 @@
 
     /// \brief Set whether the sensor is active or not
     public: void SetActive(bool value);
+    public: bool IsActive();
 
     /// \brief  Load the child sensor
     protected: virtual void LoadChild(XMLConfigNode * /*node*/) {};
@@ -88,8 +89,14 @@
 
     /// \brief True if active
     protected: bool active;
+
+    /// \brief Update period 
+    protected: double updatePeriod;
+
+    /// \brief Last update time
+    protected: double lastUpdate;
+
   };
-  
   /// \}
 }
 #endif
Index: gazebo-svn/server/sensors/camera/MonoCameraSensor.cc
===================================================================
--- gazebo-svn/server/sensors/camera/MonoCameraSensor.cc	(revision 6696)
+++ gazebo-svn/server/sensors/camera/MonoCameraSensor.cc	(working copy)
@@ -49,6 +49,7 @@
 MonoCameraSensor::MonoCameraSensor(Body *body)
     : Sensor(body), OgreCamera("Mono")
 {
+  this->active = false;
 }
 
 
@@ -120,46 +121,50 @@
 // Update the drawing
 void MonoCameraSensor::UpdateChild()
 {
-  this->UpdateCam();
 
-  this->renderTarget->update();
-
-  Ogre::HardwarePixelBufferSharedPtr mBuffer;
+  // Allocate buffer
   size_t size;
-
-  // Get access to the buffer and make an image and write it to file
-  mBuffer = this->renderTexture->getBuffer(0, 0);
-
   size = this->imageWidth * this->imageHeight * 3;
-
-  // Allocate buffer
   if (!this->saveFrameBuffer)
     this->saveFrameBuffer = new unsigned char[size];
 
-  mBuffer->lock(Ogre::HardwarePixelBuffer::HBL_READ_ONLY);
+  if (this->active)
+  {
+    this->UpdateCam();
 
-  int top = (int)((mBuffer->getHeight() - this->imageHeight) / 2.0);
-  int left = (int)((mBuffer->getWidth() - this->imageWidth) / 2.0);
-  int right = left + this->imageWidth;
-  int bottom = top + this->imageHeight;
+    this->renderTarget->update();
 
-  // Get the center of the texture in RGB 24 bit format
-  mBuffer->blitToMemory(
-    Ogre::Box(left, top, right, bottom),
+    Ogre::HardwarePixelBufferSharedPtr mBuffer;
 
-    Ogre::PixelBox(
-      this->imageWidth,
-      this->imageHeight,
-      1,
-      Ogre::PF_B8G8R8,
-      this->saveFrameBuffer)
-  );
+    // Get access to the buffer and make an image and write it to file
+    mBuffer = this->renderTexture->getBuffer(0, 0);
 
-  mBuffer->unlock();
 
+    mBuffer->lock(Ogre::HardwarePixelBuffer::HBL_READ_ONLY);
 
-  if (this->saveFrames)
-    this->SaveFrame();
+    int top = (int)((mBuffer->getHeight() - this->imageHeight) / 2.0);
+    int left = (int)((mBuffer->getWidth() - this->imageWidth) / 2.0);
+    int right = left + this->imageWidth;
+    int bottom = top + this->imageHeight;
+
+    // Get the center of the texture in RGB 24 bit format
+    mBuffer->blitToMemory(
+      Ogre::Box(left, top, right, bottom),
+
+      Ogre::PixelBox(
+        this->imageWidth,
+        this->imageHeight,
+        1,
+        Ogre::PF_B8G8R8,
+        this->saveFrameBuffer)
+    );
+
+    mBuffer->unlock();
+
+
+    if (this->saveFrames)
+      this->SaveFrame();
+  }
 }
 
 ////////////////////////////////////////////////////////////////////////////////
Index: gazebo-svn/server/sensors/camera/StereoCameraSensor.cc
===================================================================
--- gazebo-svn/server/sensors/camera/StereoCameraSensor.cc	(revision 6696)
+++ gazebo-svn/server/sensors/camera/StereoCameraSensor.cc	(working copy)
@@ -58,6 +58,7 @@
   this->depthBuffer[1] = NULL;
   this->rgbBuffer[0] = NULL;
   this->rgbBuffer[1] = NULL;
+  this->active = false;
 }
 
 
@@ -195,87 +196,90 @@
   Ogre::SceneNode *gridNode = NULL;
   int i;
 
-  this->UpdateCam();
-
-  try
+  if (this->active)
   {
-    gridNode = sceneMgr->getSceneNode("__OGRE_GRID_NODE__");
-  }
-  catch (...)
-  {
-    gridNode = NULL;
-  }
+    this->UpdateCam();
 
-  sceneMgr->_suppressRenderStateChanges(true);
+    try
+    {
+      gridNode = sceneMgr->getSceneNode("__OGRE_GRID_NODE__");
+    }
+    catch (...)
+    {
+      gridNode = NULL;
+    }
 
-  //prev_pass = sceneMgr->getPass();
+    sceneMgr->_suppressRenderStateChanges(true);
 
-  // Get pointer to the material pass
-  pass = this->depthMaterial->getBestTechnique()->getPass(0);
+    //prev_pass = sceneMgr->getPass();
 
-  if (gridNode)
-    gridNode->setVisible(false);
+    // Get pointer to the material pass
+    pass = this->depthMaterial->getBestTechnique()->getPass(0);
 
-  // Render the depth texture
-  for (i=2; i<4; i++)
-  {
+    if (gridNode)
+      gridNode->setVisible(false);
 
-    // OgreSceneManager::_render function automatically sets farClip to 0.
-    // Which normally equates to infinite distance. We don't want this. So
-    // we have to set the distance every time.
-    this->GetOgreCamera()->setFarClipDistance( this->farClip );
+    // Render the depth texture
+    for (i=2; i<4; i++)
+    {
 
+      // OgreSceneManager::_render function automatically sets farClip to 0.
+      // Which normally equates to infinite distance. We don't want this. So
+      // we have to set the distance every time.
+      this->GetOgreCamera()->setFarClipDistance( this->farClip );
 
-    Ogre::AutoParamDataSource autoParamDataSource;
 
-    vp = this->renderTargets[i]->getViewport(0);
+      Ogre::AutoParamDataSource autoParamDataSource;
 
-    // Need this line to render the ground plane. No idea why it's necessary.
-    renderSys->_setViewport(vp);
-    sceneMgr->_setPass(pass, true, false); 
-    autoParamDataSource.setCurrentPass(pass);
-    autoParamDataSource.setCurrentViewport(vp);
-    autoParamDataSource.setCurrentRenderTarget(this->renderTargets[i]);
-    autoParamDataSource.setCurrentSceneManager(sceneMgr);
-    autoParamDataSource.setCurrentCamera(this->GetOgreCamera());
-    pass->_updateAutoParamsNoLights(autoParamDataSource);
+      vp = this->renderTargets[i]->getViewport(0);
 
-    // These two lines don't seem to do anything useful
-    renderSys->_setProjectionMatrix(this->GetOgreCamera()->getProjectionMatrixRS()); 
-    renderSys->_setViewMatrix(this->GetOgreCamera()->getViewMatrix(true));
+      // Need this line to render the ground plane. No idea why it's necessary.
+      renderSys->_setViewport(vp);
+      sceneMgr->_setPass(pass, true, false); 
+      autoParamDataSource.setCurrentPass(pass);
+      autoParamDataSource.setCurrentViewport(vp);
+      autoParamDataSource.setCurrentRenderTarget(this->renderTargets[i]);
+      autoParamDataSource.setCurrentSceneManager(sceneMgr);
+      autoParamDataSource.setCurrentCamera(this->GetOgreCamera());
+      pass->_updateAutoParamsNoLights(autoParamDataSource);
 
-    // NOTE: We MUST bind parameters AFTER updating the autos
-    if (pass->hasVertexProgram())
+      // These two lines don't seem to do anything useful
+      renderSys->_setProjectionMatrix(this->GetOgreCamera()->getProjectionMatrixRS()); 
+      renderSys->_setViewMatrix(this->GetOgreCamera()->getViewMatrix(true));
+
+      // NOTE: We MUST bind parameters AFTER updating the autos
+      if (pass->hasVertexProgram())
+      {
+        renderSys->bindGpuProgram( pass->getVertexProgram()->_getBindingDelegate() );
+        renderSys->bindGpuProgramParameters(Ogre::GPT_VERTEX_PROGRAM,
+            pass->getVertexProgramParameters());
+      }
+
+      if (pass->hasFragmentProgram())
+      {   
+        renderSys->bindGpuProgram( pass->getFragmentProgram()->_getBindingDelegate() );
+        renderSys->bindGpuProgramParameters(Ogre::GPT_FRAGMENT_PROGRAM, 
+            pass->getFragmentProgramParameters());
+      }   
+      this->renderTargets[i]->update();
+    }
+
+    sceneMgr->_suppressRenderStateChanges(false); 
+
+    // Render the image texture
+    for (i=0; i<2; i++)
     {
-      renderSys->bindGpuProgram( pass->getVertexProgram()->_getBindingDelegate() );
-      renderSys->bindGpuProgramParameters(Ogre::GPT_VERTEX_PROGRAM,
-          pass->getVertexProgramParameters());
+      this->renderTargets[i]->update();
     }
 
-    if (pass->hasFragmentProgram())
-    {   
-      renderSys->bindGpuProgram( pass->getFragmentProgram()->_getBindingDelegate() );
-      renderSys->bindGpuProgramParameters(Ogre::GPT_FRAGMENT_PROGRAM, 
-          pass->getFragmentProgramParameters());
-    }   
-    this->renderTargets[i]->update();
-  }
+    if (gridNode)
+      gridNode->setVisible(true);
 
-  sceneMgr->_suppressRenderStateChanges(false); 
+    this->FillBuffers();
 
-  // Render the image texture
-  for (i=0; i<2; i++)
-  {
-    this->renderTargets[i]->update();
+    if (this->saveFrames)
+      this->SaveFrame();
   }
-
-  if (gridNode)
-    gridNode->setVisible(true);
-
-  this->FillBuffers();
-
-  if (this->saveFrames)
-    this->SaveFrame();
 }
 
 ////////////////////////////////////////////////////////////////////////////////
Index: gazebo-svn/server/sensors/ray/RaySensor.cc
===================================================================
--- gazebo-svn/server/sensors/ray/RaySensor.cc	(revision 6696)
+++ gazebo-svn/server/sensors/ray/RaySensor.cc	(working copy)
@@ -237,7 +237,7 @@
 // Update the sensor information
 void RaySensor::UpdateChild()
 {
-//  if (this->active)
+  if (this->active)
   {
     std::vector<RayGeom*>::iterator iter;
     Pose3d poseDelta;
Index: gazebo-svn/server/sensors/Sensor.cc
===================================================================
--- gazebo-svn/server/sensors/Sensor.cc	(revision 6696)
+++ gazebo-svn/server/sensors/Sensor.cc	(working copy)
@@ -32,6 +32,7 @@
 #include "World.hh"
 #include "ControllerFactory.hh"
 #include "Sensor.hh"
+#include "Simulator.hh"
 
 using namespace gazebo;
 
@@ -58,6 +59,10 @@
   this->SetName(node->GetString("name","",1));
   this->LoadController( node->GetChildByNSPrefix("controller") );
   this->LoadChild(node);
+
+  this->updatePeriod = 1.0 / (node->GetDouble("updateRate", 10) + 1e-6);
+  this->lastUpdate = -1e6;
+
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -71,7 +76,12 @@
 /// Update the sensor
 void Sensor::Update()
 {
-  this->UpdateChild();
+  if (this->lastUpdate + updatePeriod <= Simulator::Instance()->GetSimTime())
+  {
+    this->UpdateChild();
+    this->lastUpdate = Simulator::Instance()->GetSimTime();
+  }
+  // controller has its own updatRate control
   if (this->controller)
     this->controller->Update();
 }
@@ -147,4 +157,11 @@
   this->active = value;
 }
 
+////////////////////////////////////////////////////////////////////////////////
+/// \brief Set whether the sensor is active or not
+bool Sensor::IsActive()
+{
+  return this->active;
+}
 
+
Index: gazebo-svn/server/GazeboConfig.cc
===================================================================
--- gazebo-svn/server/GazeboConfig.cc	(revision 6696)
+++ gazebo-svn/server/GazeboConfig.cc	(working copy)
@@ -56,6 +56,17 @@
 
   cfgFile.open(rcFilename.c_str(), std::ios::in);
 
+  char *ogre_resource_path = getenv("OGRE_RESOURCE_PATH");
+  if(ogre_resource_path) {
+    this->ogrePaths.push_back(ogre_resource_path);
+  }
+  char *gazebo_resource_path = getenv("GAZEBO_RESOURCE_PATH");
+  if(gazebo_resource_path) {
+    this->gazeboPaths.push_back(gazebo_resource_path);
+  }
+  // if both paths are set, don't check the config file or use the defaults.
+  if(ogre_resource_path && gazebo_resource_path) return;
+
   if (cfgFile)
   {
     XMLConfig rc;
Index: gazebo-svn/server/gui/GLWindow.cc
===================================================================
--- gazebo-svn/server/gui/GLWindow.cc	(revision 6696)
+++ gazebo-svn/server/gui/GLWindow.cc	(working copy)
@@ -66,7 +66,11 @@
   this->directionVec.x = 0;
   this->directionVec.y = 0;
   this->directionVec.z = 0;
+  this->leftMousePressed = false;
+  this->rightMousePressed = false;
+  this->middleMousePressed = false;
 
+
   this->keys.clear();
 
   if (activeWin == NULL)
@@ -91,8 +95,9 @@
   this->userCamera = new UserCamera( this );
   this->userCamera->Load(NULL);
   this->userCamera->Init();
+  this->userCamera->Translate( Vector3(5, 0, 3) );
+  this->userCamera->RotateYaw( DTOR(180) );
   this->userCamera->RotatePitch( DTOR(30) );
-  this->userCamera->Translate( Vector3(-5, 0, 1) );
 
   this->activeCamera = this->userCamera;
 }
@@ -235,6 +240,21 @@
       this->activeCamera->RotateYaw(DTOR(-d.x * this->rotateAmount));
       this->activeCamera->RotatePitch(DTOR(d.y * this->rotateAmount));
     }
+    if (this->rightMousePressed)
+    {
+      Vector2<int> d = this->mousePos - this->prevMousePos;
+      this->directionVec.x = 0;
+      this->directionVec.y =  d.x * this->moveAmount;
+      this->directionVec.z =  d.y * this->moveAmount;
+    }
+    if (this->middleMousePressed)
+    {
+      Vector2<int> d = this->mousePos - this->prevMousePos;
+      this->directionVec.x =  d.y * this->moveAmount;
+      this->directionVec.y =  0;
+      this->directionVec.z =  0;
+    }
+
   }
 
   this->mouseDrag = true;
@@ -247,12 +267,28 @@
   std::map<int,int>::iterator iter;
   this->keys[keyNum] = 1;
 
+  // loop through the keys to find the modifiers -- swh
+  float moveAmount = this->moveAmount;
   for (iter = this->keys.begin(); iter!= this->keys.end(); iter++)
   {
     if (iter->second == 1)
     {
       switch (iter->first)
       {
+        case FL_Control_L:
+        case FL_Control_R:
+          moveAmount = this->moveAmount * 10;
+          break;
+      }
+    }
+  }
+
+  for (iter = this->keys.begin(); iter!= this->keys.end(); iter++)
+  {
+    if (iter->second == 1)
+    {
+      switch (iter->first)
+      {
         case '=':
         case '+':
           this->moveAmount *= 2;
Index: gazebo-svn/server/World.hh
===================================================================
--- gazebo-svn/server/World.hh	(revision 6696)
+++ gazebo-svn/server/World.hh	(working copy)
@@ -91,6 +91,26 @@
   /// \return Pointer to the physics engine
   public: PhysicsEngine *GetPhysicsEngine() const;
 
+  /// Get the simulation time
+  /// \return The simulation time
+  public: double GetSimTime() const;
+
+  /// Get the pause time
+  /// \return The pause time
+  public: double GetPauseTime() const;
+
+  /// Get the start time
+  /// \return The start time
+  public: double GetStartTime() const;
+
+  /// Get the real time (elapsed time)
+  /// \return The real time
+  public: double GetRealTime() const;
+
+  /// \brief Get the wall clock time
+  /// \return The wall clock time
+  public: double GetWallTime() const;
+
   /// \brief Load all entities
   /// \param node XMLConfg node pointer
   /// \param parent Parent of the model to load
@@ -185,6 +205,9 @@
   /// Simulation interface
   private: SimulationIface *simIface;
 
+  /// Current simulation time
+  private: double simTime, pauseTime, startTime;
+
   private: friend class DestroyerT<World>;
   private: friend class SingletonT<World>;
 };
Index: gazebo-svn/server/controllers/camera/stereo/Stereo_Camera.cc
===================================================================
--- gazebo-svn/server/controllers/camera/stereo/Stereo_Camera.cc	(revision 6696)
+++ gazebo-svn/server/controllers/camera/stereo/Stereo_Camera.cc	(working copy)
@@ -87,26 +87,59 @@
 // Update the controller
 void Stereo_Camera::UpdateChild()
 {
-  if (this->cameraIface)
+  bool cameraOpen = false;
+  bool stereoOpen = false;
+
+
+  // do this first so there's chance for sensor to run 1 frame after activate
+  if (this->myParent->IsActive())
   {
-    this->cameraIface->Lock(1);
-    if (this->cameraIface->data->head.openCount > 0)
-      this->PutCameraData();
-    this->cameraIface->Unlock();
+    if (this->cameraIface)
+    {
+      this->cameraIface->Lock(1);
+      if (this->cameraIface->data->head.openCount > 0)
+        this->PutCameraData();
+      this->cameraIface->Unlock();
 
-    // New data is available
-    this->cameraIface->Post();
+      // New data is available
+      this->cameraIface->Post();
+    }
+
+    if (this->stereoIface)
+    {
+      this->stereoIface->Lock(1);
+      if (this->stereoIface->data->head.openCount > 0)
+        this->PutStereoData();
+      this->stereoIface->Unlock();
+
+      this->stereoIface->Post();
+    }
   }
 
-  if (this->stereoIface)
+
+  // activate if iface open
+  if (this->cameraIface->Lock(1))
   {
-    this->stereoIface->Lock(1);
-    if (this->stereoIface->data->head.openCount > 0)
-      this->PutStereoData();
+    cameraOpen = (this->cameraIface->GetOpenCount() > 0);
+    //std::cout << " stereo camera open count " << this->cameraIface->GetOpenCount() << std::endl;
+    this->cameraIface->Unlock();
+  }
+
+  if (this->stereoIface->Lock(1))
+  {
+    stereoOpen = (this->stereoIface->GetOpenCount() > 0);
+    //std::cout << " stereo depth  open count " << this->stereoIface->GetOpenCount() << std::endl;
     this->stereoIface->Unlock();
+  }
 
-    this->stereoIface->Post();
-  }
+  if (cameraOpen || stereoOpen)
+    this->myParent->SetActive(true);
+  else
+    this->myParent->SetActive(false);
+
+  //std::cout << " stereo     active " << this->myParent->IsActive() << std::endl;
+
+
 }
 
 ////////////////////////////////////////////////////////////////////////////////
Index: gazebo-svn/server/controllers/camera/generic/Generic_Camera.cc
===================================================================
--- gazebo-svn/server/controllers/camera/generic/Generic_Camera.cc	(revision 6696)
+++ gazebo-svn/server/controllers/camera/generic/Generic_Camera.cc	(working copy)
@@ -79,7 +79,24 @@
 // Update the controller
 void Generic_Camera::UpdateChild()
 {
-  this->PutCameraData();
+
+  // do this first so there's chance for sensor to run 1 frame after activate
+  if (this->myParent->IsActive())
+    this->PutCameraData();
+
+  // activate if iface open
+  if (this->cameraIface->Lock(1))
+  {
+    if (this->cameraIface->GetOpenCount() > 0)
+      this->myParent->SetActive(true);
+    else
+      this->myParent->SetActive(false);
+
+    //std::cout << " camera open count " << this->cameraIface->GetOpenCount() << std::endl;
+    this->cameraIface->Unlock();
+  }
+  //std::cout << " camera     active " << this->myParent->IsActive() << std::endl;
+
 }
 
 ////////////////////////////////////////////////////////////////////////////////
Index: gazebo-svn/server/controllers/ControllerFactory.cc
===================================================================
--- gazebo-svn/server/controllers/ControllerFactory.cc	(revision 6696)
+++ gazebo-svn/server/controllers/ControllerFactory.cc	(working copy)
@@ -42,6 +42,7 @@
 // Register a controller class.  Use by dynamically loaded modules
 void ControllerFactory::RegisterController(std::string type, std::string classname, ControllerFactoryFn factoryfn)
 {
+  std::cout << " controllers " << classname << " registered " << std::endl;
   controllers[classname] = factoryfn;
 }
 
Index: gazebo-svn/server/controllers/laser/sicklms200/SickLMS200_Laser.cc
===================================================================
--- gazebo-svn/server/controllers/laser/sicklms200/SickLMS200_Laser.cc	(revision 6696)
+++ gazebo-svn/server/controllers/laser/sicklms200/SickLMS200_Laser.cc	(working copy)
@@ -98,6 +98,7 @@
   if (this->laserIface->Lock(1))
   {
     laserOpened = this->laserIface->GetOpenCount() > 0;
+    //std::cout << " laser open count " << this->laserIface->GetOpenCount() << std::endl;
     this->laserIface->Unlock();
   }
 
@@ -123,6 +124,8 @@
   {
     this->myParent->SetActive(false);
   }
+  //std::cout << "            active " << this->myParent->IsActive() << std::endl;
+
 }
 
 ////////////////////////////////////////////////////////////////////////////////
Index: gazebo-svn/server/controllers/Controller.cc
===================================================================
--- gazebo-svn/server/controllers/Controller.cc	(revision 6696)
+++ gazebo-svn/server/controllers/Controller.cc	(working copy)
@@ -141,10 +141,10 @@
 /// Update the controller. Called every cycle.
 void Controller::Update()
 {
-  if (lastUpdate + updatePeriod <= Simulator::Instance()->GetSimTime())
+  if (this->lastUpdate + updatePeriod <= Simulator::Instance()->GetSimTime())
   {
     this->UpdateChild();
-    lastUpdate = Simulator::Instance()->GetSimTime();
+    this->lastUpdate = Simulator::Instance()->GetSimTime();
   }
 }
 
Index: gazebo-svn/server/World.cc
===================================================================
--- gazebo-svn/server/World.cc	(revision 6696)
+++ gazebo-svn/server/World.cc	(working copy)
@@ -27,6 +27,7 @@
 #include <assert.h>
 #include <sstream>
 #include <fstream>
+#include <sys/time.h> //gettimeofday
 
 #include "Global.hh"
 #include "GazeboError.hh"
@@ -57,6 +58,9 @@
   this->server = NULL;
   this->simIface = NULL;
 
+  this->simTime = 0.0;
+  this->pauseTime = 0.0;
+  this->startTime = 0.0;
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -157,6 +161,7 @@
 
   this->physicsEngine->Init();
 
+  this->startTime = this->GetWallTime();
   this->toAddModels.clear();
   this->toDeleteModels.clear();
 
@@ -170,6 +175,8 @@
   std::vector< Model* >::iterator miter;
   std::vector< Model* >::iterator miter2;
 
+  this->simTime += this->physicsEngine->GetStepTime();
+
   // Update all the models
   for (miter=this->models.begin(); miter!=this->models.end(); miter++)
   {
@@ -183,6 +190,10 @@
   {
     this->physicsEngine->Update();
   }
+  else
+  {
+    this->pauseTime += this->physicsEngine->GetStepTime();
+  }
 
   this->UpdateSimulationIface();
 
@@ -250,6 +261,41 @@
   return this->physicsEngine;
 }
 
+////////////////////////////////////////////////////////////////////////////////
+// Get the simulation time
+double World::GetSimTime() const
+{
+  return this->simTime;
+}
+////////////////////////////////////////////////////////////////////////////////
+// Get the pause time
+double World::GetPauseTime() const
+{
+  return this->pauseTime;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+/// Get the start time
+double World::GetStartTime() const
+{
+  return this->startTime;
+}
+////////////////////////////////////////////////////////////////////////////////
+/// Get the real time (elapsed time)
+double World::GetRealTime() const
+{
+  return this->GetWallTime() - this->startTime;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+/// Get the wall clock time
+double World::GetWallTime() const
+{
+  struct timeval tv;
+  gettimeofday(&tv, NULL);
+  return tv.tv_sec + tv.tv_usec * 1e-6;
+}
+
 ///////////////////////////////////////////////////////////////////////////////
 // Load a model
 int World::LoadEntities(XMLConfigNode *node, Model *parent)
Index: gazebo-svn/SConstruct
===================================================================
--- gazebo-svn/SConstruct	(revision 6696)
+++ gazebo-svn/SConstruct	(working copy)
@@ -24,6 +24,8 @@
 parseConfigs=['pkg-config --cflags --libs OGRE',
               'xml2-config --cflags --libs', 
       	      'ode-config --cflags --libs',
+      	      'rospack export/cpp/cflags freeimage',
+      	      'rospack export/cpp/lflags freeimage',
               'fltk-config --cflags --libs --ldflags --use-gl --use-images',
               'pkg-config --cflags --libs xft'
               ]
Index: gazebo-svn/worlds/stereocamera.world
===================================================================
--- gazebo-svn/worlds/stereocamera.world	(revision 6696)
+++ gazebo-svn/worlds/stereocamera.world	(working copy)
@@ -105,10 +105,10 @@
         <saveFramePath>frames</saveFramePath>
         <baseline>0.2</baseline>
 
-        <controller:stereo_camera name="stereo_camera_controller">
+        <controller:stereocamera name="stereo_camera_controller">
           <interface:stereocamera name="stereo_iface_0" />
           <interface:camera name="camera_iface_0" />
-        </controller:stereo_camera>
+        </controller:stereocamera>
       </sensor:stereocamera>
     </body:empty>
   </model:physical>
