Index: gazebo-svn/player/SConscript
===================================================================
--- gazebo-svn/player/SConscript	(revision 6696)
+++ gazebo-svn/player/SConscript	(working copy)
@@ -1,7 +1,8 @@
 import os
 Import('env install_prefix staticObjs sharedObjs subdirs')
 
-parseConfigs = ['pkg-config --cflags --libs playerc++']
+parseConfigs = ['pkg-config --cflags --libs playerc++',
+                'pkg-config --cflags --libs playerc']
 
 sources = ['GazeboDriver.cc',
            'GazeboClient.cc',
Index: gazebo-svn/libgazebo/Server.cc
===================================================================
--- gazebo-svn/libgazebo/Server.cc	(revision 6696)
+++ gazebo-svn/libgazebo/Server.cc	(working copy)
@@ -38,6 +38,7 @@
 #include <sys/sem.h>
 #include <sstream>
 #include <iostream>
+#include <signal.h>
 
 #include "gazebo.h"
 
@@ -92,6 +93,42 @@
 
   std::cout << "creating " << this->filename << "\n";
 
+  // check to see if there is already a directory created.
+  struct stat astat;
+  if (stat(this->filename.c_str(), &astat) == 0) {
+    // directory already exists, check gazebo.pid to see if 
+    // another gazebo is already running.
+
+    std::string pidfn = this->filename + "/gazebo.pid";
+    
+    FILE *fp = fopen(pidfn.c_str(), "r");
+    if(fp) {
+      int pid;
+      fscanf(fp, "%d", &pid);
+      fclose(fp);
+      std::cout << "found a pid file: pid=" << pid << "\n";
+
+      if(kill(pid, 0) == 0) {
+	// a gazebo process is still alive.
+	errStream << "directory [" <<  this->filename
+		  <<  "] already exists (previous crash?)\n"
+		  << "gazebo (pid=" << pid << ") is still running.";
+	throw(errStream.str());
+      } else {
+	// the gazebo process is not alive.
+	// remove directory.
+	std::cout << "The gazebo process is not alive.\n";
+
+	// remove the existing directory.
+	std::string cmd = "rm -rf '" + this->filename + "'";
+	if(system(cmd.c_str()) != 0) {
+	  errStream << "couldn't remove directory [" <<  this->filename << "]";
+	  throw(errStream.str());
+	}
+      }
+    }
+  }
+
   // Create the directory
   if (mkdir(this->filename.c_str(), S_IRUSR | S_IWUSR | S_IXUSR) != 0)
   {
@@ -108,7 +145,17 @@
       <<  strerror(errno) << "]";
       throw(errStream.str());
     }
+
   }
+
+  // write the PID to a file
+  std::string pidfn = this->filename + "/gazebo.pid";
+    
+  FILE *fp = fopen(pidfn.c_str(), "w");
+  if(fp) {
+    fprintf(fp, "%d\n", getpid());
+    fclose(fp);
+  }
 }
 
 
@@ -120,6 +167,15 @@
 
   std::cout << "deleting " << this->filename << "\n";
 
+  // unlink the pid file
+  std::string pidfn = this->filename + "/gazebo.pid";
+  if (unlink(pidfn.c_str()) < 0)
+  {
+    std::ostringstream stream;
+    stream << "error deleting pid file: " << strerror(errno);
+    throw(stream.str());
+  }
+
   // Delete the server dir
   if (rmdir(this->filename.c_str()) != 0)
   {
Index: gazebo-svn/libgazebo/Iface.cc
===================================================================
--- gazebo-svn/libgazebo/Iface.cc	(revision 6696)
+++ gazebo-svn/libgazebo/Iface.cc	(working copy)
@@ -55,6 +55,8 @@
 GZ_REGISTER_IFACE("factory", FactoryIface);
 GZ_REGISTER_IFACE("gripper", GripperIface);
 GZ_REGISTER_IFACE("actarray", ActarrayIface);
+GZ_REGISTER_IFACE("pr2array", PR2ArrayIface);
+GZ_REGISTER_IFACE("pr2gripper", PR2GripperIface);
 GZ_REGISTER_IFACE("ptz", PTZIface);
 GZ_REGISTER_IFACE("stereocamera", StereoCameraIface);
 
Index: gazebo-svn/libgazebo/gazebo.h
===================================================================
--- gazebo-svn/libgazebo/gazebo.h	(revision 6696)
+++ gazebo-svn/libgazebo/gazebo.h	(working copy)
@@ -550,7 +550,7 @@
 
 
 /// Maximum image pixels (width x height)
-#define GAZEBO_CAMERA_MAX_IMAGE_SIZE 640 * 480 * 3
+#define GAZEBO_CAMERA_MAX_IMAGE_SIZE 1024 * 1024 * 3
 
 /// \brief Camera interface data
 class CameraData
@@ -1057,6 +1057,30 @@
 
   /// Lift down flag
   public: int lift_down;
+
+  /// Enable flag
+  public: int cmdEnableMotor;
+
+  /// Gripper Position Rate Command
+  public: float cmdPositionRate;
+  /// Gripper Force Command
+  public: float cmdForce;
+  /// Gripper Gap Command
+  public: float cmdGap;
+
+  /// Gripper force
+  public: double gripperForce;
+  /// Gripper controller gains
+  public: double pGain;
+  public: double dGain;
+  public: double iGain;
+
+  /// Position
+  public: float actualFingerPosition[2];
+  /// Position Rate
+  public: float actualFingerPositionRate[2];
+
+
 };
 
 /// \brief Gripper interface
@@ -1254,9 +1278,327 @@
 /// \} */
 
 
+
+
 /***************************************************************************/
 /// \addtogroup libgazebo_iface
 /// \{
+/** \defgroup gripper_iface gripper
+
+  \brief PR2 Gripper interface
+
+The gripper interface allows control of a simple pseudo-1-DOF PR2 gripper, such as
+that found on the Pioneer series robots.
+
+
+\{
+*/
+
+/** Gripper state: open */
+#define GAZEBO_PR2GRIPPER_STATE_OPEN 1
+/** Gripper state: closed */
+#define GAZEBO_PR2GRIPPER_STATE_CLOSED 2
+/** Gripper state: moving */
+#define GAZEBO_PR2GRIPPER_STATE_MOVING 3
+/** Gripper state: error */
+#define GAZEBO_PR2GRIPPER_STATE_ERROR 4
+
+/** Gripper command: open */
+#define GAZEBO_PR2GRIPPER_CMD_OPEN 1
+/** Gripper command: close */
+#define GAZEBO_PR2GRIPPER_CMD_CLOSE 2
+/** Gripper command: stop */
+#define GAZEBO_PR2GRIPPER_CMD_STOP 3
+/** Gripper command: store */
+#define GAZEBO_PR2GRIPPER_CMD_STORE 4
+/** Gripper command: retrieve */
+#define GAZEBO_PR2GRIPPER_CMD_RETRIEVE 5
+
+
+/// \brief Fudicial interface data
+class PR2GripperData
+{
+  public: GazeboData head;
+
+  /// \brief Current command for the gripper
+  public: int cmd;
+
+  /// Current state of the gripper
+  public: int state;
+
+  /// Gripped limit reached flag
+  public: int grip_limit_reach;
+
+  /// Lift limit reached flag
+  public: int lift_limit_reach;
+
+  /// Outer beam obstruct flag
+  public: int outer_beam_obstruct;
+
+  /// control mode, TODO: yet to be defined
+  public: int controlMode;
+
+  /// Inner beam obstructed flag
+  public: int inner_beam_obstruct;
+
+  /// Left paddle open flag
+  public: int left_paddle_open;
+
+  /// Right paddle open flag
+  public: int right_paddle_open;
+
+  /// Lift up flag
+  public: int lift_up;
+
+  /// Lift down flag
+  public: int lift_down;
+
+  /// Enable flag
+  public: int cmdEnableMotor;
+
+  /// Gripper Position Rate Command
+  public: float cmdPositionRate;
+  /// Gripper Force Command
+  public: float cmdForce;
+  /// Gripper Gap Command
+  public: float cmdGap;
+
+  /// Gripper force
+  public: double gripperForce;
+  /// Gripper controller gains
+  public: double pGain;
+  public: double dGain;
+  public: double iGain;
+
+  /// Position
+  public: float actualFingerPosition[2];
+  /// Position Rate
+  public: float actualFingerPositionRate[2];
+
+
+};
+
+/// \brief Gripper interface
+class PR2GripperIface : public Iface
+{
+  /// \brief Constructor
+  public: PR2GripperIface():Iface("pr2gripper", sizeof(PR2GripperIface)+sizeof(PR2GripperData)) {}
+
+  /// \brief Destructor
+  public: virtual ~PR2GripperIface() {this->data = NULL;}
+
+  /// \brief Create the server
+  public: virtual void Create(Server *server, std::string id)
+          {
+            Iface::Create(server,id); 
+            this->data = (PR2GripperData*)this->mMap; 
+          }
+
+  /// \brief Open the iface 
+  public: virtual void Open(Client *client, std::string id)
+          {
+            Iface::Open(client,id); 
+            this->data = (PR2GripperData*)this->mMap; 
+          }
+
+  /// Pointer to the gripper data
+  public: PR2GripperData *data;
+};
+
+/** \} */
+/// \}
+
+
+/***************************************************************************/
+/// \addtogroup libgazebo_iface 
+/// \{
+/** \defgroup pr2array_iface actarray
+
+  \brief PR2 Array
+
+The PR2 array interface allows a user to control a set of actuators.
+
+\{
+*/
+
+/// maximum number of actuators 
+#define GAZEBO_PR2ARRAY_MAX_NUM_ACTUATORS 64
+#define GAZEBO_PR2ARRAY_JOINT_POSITION_MODE 0
+#define GAZEBO_PR2ARRAY_JOINT_SPEED_MODE 1
+#define GAZEBO_PR2ARRAY_JOINT_CURRENT_MODE 2
+
+//Actuator states
+/// Idle state
+#define GAZEBO_PR2ARRAY_ACTSTATE_IDLE     1
+
+/// Moving state 
+#define GAZEBO_PR2ARRAY_ACTSTATE_MOVING   2
+
+/// Braked state 
+#define GAZEBO_PR2ARRAY_ACTSTATE_BRAKED   3
+
+/// Stalled state 
+#define GAZEBO_PR2ARRAY_ACTSTATE_STALLED  4
+
+/// Linear type 
+#define GAZEBO_PR2ARRAY_TYPE_LINEAR       1
+/// Rotary type
+#define GAZEBO_PR2ARRAY_TYPE_ROTARY       2
+
+/// Request subtype: power 
+#define GAZEBO_PR2ARRAY_POWER_REQ         1
+/// Request subtype: brakes 
+#define GAZEBO_PR2ARRAY_BRAKES_REQ        2
+/// Request subtype: get geometry 
+#define GAZEBO_PR2ARRAY_GET_GEOM_REQ      3
+/// Request subtype: speed
+#define GAZEBO_PR2ARRAY_SPEED_REQ         4
+
+/// Command subtype: position 
+#define GAZEBO_PR2ARRAY_POS_CMD           1
+/// Command subtype: speed 
+#define GAZEBO_PR2ARRAY_SPEED_CMD         2
+/// Command subtype: home 
+#define GAZEBO_PR2ARRAY_HOME_CMD          3
+
+
+/// \brief Actuator geometry 
+class PR2ArrayActuatorGeom
+{
+
+/// Data subtype: state
+#define GAZEBO_PR2ARRAY_DATA_STATE        1
+
+
+  /// The type of the actuator - linear or rotary.
+  public: uint8_t type;
+
+  /// Min range of motion (m or rad depending on the type)
+  public: float min;
+
+  /// Center position (m or rad)
+  public: float center;
+
+  /// Max range of motion (m or rad depending on the type)
+  public: float max;
+
+  /// Home position (m or rad depending on the type)
+  public: float home;
+
+  /// The configured speed - different from current speed. 
+  public: float config_speed;
+
+  /// The maximum achievable speed of the actuator.
+  public: float max_speed;
+
+  /// If the actuator has brakes or not. 
+  public: uint8_t hasbrakes;
+};
+
+/// \brief Structure containing a single actuator's information 
+class PR2ArrayActuator
+{
+  /// The position of the actuator in m or rad depending on the type.
+  public: float actualPosition;
+  /// The speed of the actuator in m/s or rad/s depending on the type. 
+  public: float actualSpeed;
+  /// The current state of the actuator. 
+  public: uint8_t state;
+}; 
+
+  typedef struct
+   {
+      double timestamp;
+      double actualPosition;
+      double actualSpeed;
+      double actualEffectorForce;
+
+      int controlMode;
+      int jointType;
+
+      double cmdPosition;
+      double cmdSpeed;
+      double cmdEffectorForce;
+
+      int cmdEnableMotor;
+
+      double pGain;
+      double iGain;
+      double dGain;
+      double iClamp;
+      double saturationTorque;
+   } JointData;
+
+/// \brief The actuator array data packet. 
+class PR2ArrayData
+{
+  public: GazeboData head;
+
+  /// The number of actuators in the array. 
+  public: unsigned int actuators_count;
+  
+  /// The actuator data. 
+//  public: PR2ArrayActuator actuators[GAZEBO_PR2ARRAY_MAX_NUM_ACTUATORS];
+    public: JointData actuators[GAZEBO_PR2ARRAY_MAX_NUM_ACTUATORS];
+  
+  /// The actuators geoms 
+  public: PR2ArrayActuatorGeom actuator_geoms[GAZEBO_PR2ARRAY_MAX_NUM_ACTUATORS];
+  
+  /// position commands
+  public: float cmd_pos[GAZEBO_PR2ARRAY_MAX_NUM_ACTUATORS];
+  
+  /// speed commands
+  public: float cmd_speed[GAZEBO_PR2ARRAY_MAX_NUM_ACTUATORS];
+  
+  /// bad command flag - (speed to high set for the actuators or position not reachable)
+  public: int bad_cmd;
+
+  /// True if new command
+  public: bool new_cmd;
+  
+  /// position / speed comand
+  public: unsigned int joint_mode[GAZEBO_PR2ARRAY_MAX_NUM_ACTUATORS];
+  
+};
+
+/// \brief The PR2Array interface
+class PR2ArrayIface : public Iface
+{
+  /// \brief Create an interface
+  public: PR2ArrayIface():Iface("pr2array", sizeof(PR2ArrayIface)+sizeof(PR2ArrayData)) {}
+
+  /// \brief Destroy and Interface
+  public: virtual ~PR2ArrayIface() {this->data = NULL;}
+
+  /// \brief Create the interface (used by Gazebo server)
+  /// \param server Pointer to the server
+  /// \param id Id of the interface
+  public: virtual void Create(Server *server, std::string id)
+          {
+           Iface::Create(server,id); 
+           this->data = (PR2ArrayData*)this->mMap; 
+          }
+
+  /// \brief Open an existing interface
+  /// \param client Pointer to the client
+  /// \param id Id of the interface
+  public: virtual void Open(Client *client, std::string id)
+          {
+            Iface::Open(client,id); 
+            this->data = (PR2ArrayData*)this->mMap; 
+          }
+
+  /// Pointer to the act array data
+  public: PR2ArrayData *data;
+};
+
+/** \} */
+/// \} */
+
+
+/***************************************************************************/
+/// \addtogroup libgazebo_iface
+/// \{
 /** \defgroup ptz_iface ptz
 
   \brief PTZ interface
Index: gazebo-svn/server/physics/HingeJoint.cc
===================================================================
--- gazebo-svn/server/physics/HingeJoint.cc	(revision 6696)
+++ gazebo-svn/server/physics/HingeJoint.cc	(working copy)
@@ -38,6 +38,7 @@
     : Joint()
 {
   this->jointId = dJointCreateHinge( worldId, NULL );
+  this->type = Joint::HINGE;
 }
 
 
Index: gazebo-svn/server/physics/SliderJoint.cc
===================================================================
--- gazebo-svn/server/physics/SliderJoint.cc	(revision 6696)
+++ gazebo-svn/server/physics/SliderJoint.cc	(working copy)
@@ -35,6 +35,8 @@
     : Joint()
 {
   this->jointId = dJointCreateSlider( worldId, NULL );
+  this->type = Joint::SLIDER;
+  fprintf(stderr," slider jointId %d\n",this->jointId);
 }
 
 
Index: gazebo-svn/server/GazeboConfig.cc
===================================================================
--- gazebo-svn/server/GazeboConfig.cc	(revision 6696)
+++ gazebo-svn/server/GazeboConfig.cc	(working copy)
@@ -56,6 +56,17 @@
 
   cfgFile.open(rcFilename.c_str(), std::ios::in);
 
+  char *ogre_resource_path = getenv("OGRE_RESOURCE_PATH");
+  if(ogre_resource_path) {
+    this->ogrePaths.push_back(ogre_resource_path);
+  }
+  char *gazebo_resource_path = getenv("GAZEBO_RESOURCE_PATH");
+  if(gazebo_resource_path) {
+    this->gazeboPaths.push_back(gazebo_resource_path);
+  }
+  // if both paths are set, don't check the config file or use the defaults.
+  if(ogre_resource_path && gazebo_resource_path) return;
+
   if (cfgFile)
   {
     XMLConfig rc;
Index: gazebo-svn/server/gui/GLWindow.cc
===================================================================
--- gazebo-svn/server/gui/GLWindow.cc	(revision 6696)
+++ gazebo-svn/server/gui/GLWindow.cc	(working copy)
@@ -66,7 +66,11 @@
   this->directionVec.x = 0;
   this->directionVec.y = 0;
   this->directionVec.z = 0;
+  this->leftMousePressed = false;
+  this->rightMousePressed = false;
+  this->middleMousePressed = false;
 
+
   this->keys.clear();
 
   if (activeWin == NULL)
@@ -235,6 +239,21 @@
       this->activeCamera->RotateYaw(DTOR(-d.x * this->rotateAmount));
       this->activeCamera->RotatePitch(DTOR(d.y * this->rotateAmount));
     }
+    if (this->rightMousePressed)
+    {
+      Vector2<int> d = this->mousePos - this->prevMousePos;
+      this->directionVec.x = 0;
+      this->directionVec.y =  d.x * this->moveAmount;
+      this->directionVec.z =  d.y * this->moveAmount;
+    }
+    if (this->middleMousePressed)
+    {
+      Vector2<int> d = this->mousePos - this->prevMousePos;
+      this->directionVec.x =  d.y * this->moveAmount;
+      this->directionVec.y =  0;
+      this->directionVec.z =  0;
+    }
+
   }
 
   this->mouseDrag = true;
@@ -247,12 +266,28 @@
   std::map<int,int>::iterator iter;
   this->keys[keyNum] = 1;
 
+  // loop through the keys to find the modifiers -- swh
+  float moveAmount = this->moveAmount;
   for (iter = this->keys.begin(); iter!= this->keys.end(); iter++)
   {
     if (iter->second == 1)
     {
       switch (iter->first)
       {
+        case FL_Control_L:
+        case FL_Control_R:
+          moveAmount = this->moveAmount * 10;
+          break;
+      }
+    }
+  }
+
+  for (iter = this->keys.begin(); iter!= this->keys.end(); iter++)
+  {
+    if (iter->second == 1)
+    {
+      switch (iter->first)
+      {
         case '=':
         case '+':
           this->moveAmount *= 2;
Index: gazebo-svn/server/World.hh
===================================================================
--- gazebo-svn/server/World.hh	(revision 6696)
+++ gazebo-svn/server/World.hh	(working copy)
@@ -91,6 +91,26 @@
   /// \return Pointer to the physics engine
   public: PhysicsEngine *GetPhysicsEngine() const;
 
+  /// Get the simulation time
+  /// \return The simulation time
+  public: double GetSimTime() const;
+
+  /// Get the pause time
+  /// \return The pause time
+  public: double GetPauseTime() const;
+
+  /// Get the start time
+  /// \return The start time
+  public: double GetStartTime() const;
+
+  /// Get the real time (elapsed time)
+  /// \return The real time
+  public: double GetRealTime() const;
+
+  /// \brief Get the wall clock time
+  /// \return The wall clock time
+  public: double GetWallTime() const;
+
   /// \brief Load all entities
   /// \param node XMLConfg node pointer
   /// \param parent Parent of the model to load
@@ -185,6 +205,9 @@
   /// Simulation interface
   private: SimulationIface *simIface;
 
+  /// Current simulation time
+  private: double simTime, pauseTime, startTime;
+
   private: friend class DestroyerT<World>;
   private: friend class SingletonT<World>;
 };
Index: gazebo-svn/server/World.cc
===================================================================
--- gazebo-svn/server/World.cc	(revision 6696)
+++ gazebo-svn/server/World.cc	(working copy)
@@ -27,6 +27,7 @@
 #include <assert.h>
 #include <sstream>
 #include <fstream>
+#include <sys/time.h> //gettimeofday
 
 #include "Global.hh"
 #include "GazeboError.hh"
@@ -57,6 +58,9 @@
   this->server = NULL;
   this->simIface = NULL;
 
+  this->simTime = 0.0;
+  this->pauseTime = 0.0;
+  this->startTime = 0.0;
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -157,6 +161,7 @@
 
   this->physicsEngine->Init();
 
+  this->startTime = this->GetWallTime();
   this->toAddModels.clear();
   this->toDeleteModels.clear();
 
@@ -170,6 +175,8 @@
   std::vector< Model* >::iterator miter;
   std::vector< Model* >::iterator miter2;
 
+  this->simTime += this->physicsEngine->GetStepTime();
+
   // Update all the models
   for (miter=this->models.begin(); miter!=this->models.end(); miter++)
   {
@@ -183,6 +190,10 @@
   {
     this->physicsEngine->Update();
   }
+  else
+  {
+    this->pauseTime += this->physicsEngine->GetStepTime();
+  }
 
   this->UpdateSimulationIface();
 
@@ -250,6 +261,41 @@
   return this->physicsEngine;
 }
 
+////////////////////////////////////////////////////////////////////////////////
+// Get the simulation time
+double World::GetSimTime() const
+{
+  return this->simTime;
+}
+////////////////////////////////////////////////////////////////////////////////
+// Get the pause time
+double World::GetPauseTime() const
+{
+  return this->pauseTime;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+/// Get the start time
+double World::GetStartTime() const
+{
+  return this->startTime;
+}
+////////////////////////////////////////////////////////////////////////////////
+/// Get the real time (elapsed time)
+double World::GetRealTime() const
+{
+  return this->GetWallTime() - this->startTime;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+/// Get the wall clock time
+double World::GetWallTime() const
+{
+  struct timeval tv;
+  gettimeofday(&tv, NULL);
+  return tv.tv_sec + tv.tv_usec * 1e-6;
+}
+
 ///////////////////////////////////////////////////////////////////////////////
 // Load a model
 int World::LoadEntities(XMLConfigNode *node, Model *parent)
Index: gazebo-svn/SConstruct
===================================================================
--- gazebo-svn/SConstruct	(revision 6696)
+++ gazebo-svn/SConstruct	(working copy)
@@ -24,6 +24,8 @@
 parseConfigs=['pkg-config --cflags --libs OGRE',
               'xml2-config --cflags --libs', 
       	      'ode-config --cflags --libs',
+      	      'rospack export/cpp/cflags freeimage',
+      	      'rospack export/cpp/lflags freeimage',
               'fltk-config --cflags --libs --ldflags --use-gl --use-images',
               'pkg-config --cflags --libs xft'
               ]
