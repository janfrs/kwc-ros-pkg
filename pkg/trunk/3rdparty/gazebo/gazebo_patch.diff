Index: player/SConscript
===================================================================
--- player/SConscript	(revision 6981)
+++ player/SConscript	(working copy)
@@ -1,7 +1,8 @@
 import os
 Import('env install_prefix staticObjs sharedObjs subdirs')
 
-parseConfigs = ['pkg-config --cflags --libs playerc++']
+parseConfigs = ['pkg-config --cflags --libs playerc++',
+                'pkg-config --cflags --libs playerc']
 
 sources = ['GazeboDriver.cc',
            'GazeboClient.cc',
Index: libgazebo/Iface.cc
===================================================================
--- libgazebo/Iface.cc	(revision 6981)
+++ libgazebo/Iface.cc	(working copy)
@@ -55,6 +55,8 @@
 GZ_REGISTER_IFACE("factory", FactoryIface);
 GZ_REGISTER_IFACE("gripper", GripperIface);
 GZ_REGISTER_IFACE("actarray", ActarrayIface);
+GZ_REGISTER_IFACE("pr2array", PR2ArrayIface);
+GZ_REGISTER_IFACE("pr2gripper", PR2GripperIface);
 GZ_REGISTER_IFACE("ptz", PTZIface);
 GZ_REGISTER_IFACE("stereocamera", StereoCameraIface);
 
Index: libgazebo/gazebo.h
===================================================================
--- libgazebo/gazebo.h	(revision 6981)
+++ libgazebo/gazebo.h	(working copy)
@@ -558,7 +558,7 @@
 
 
 /// Maximum image pixels (width x height)
-#define GAZEBO_CAMERA_MAX_IMAGE_SIZE 640 * 480 * 3
+#define GAZEBO_CAMERA_MAX_IMAGE_SIZE 1024 * 1024 * 3
 
 /// \brief Camera interface data
 class CameraData
@@ -586,6 +586,9 @@
   /// Pose of the camera
   public: Pose camera_pose;
   
+  /// Is camera stream opened?
+  public: bool opened;
+  
 };
 
 /// \brief The camera interface
@@ -604,6 +607,7 @@
           {
             Iface::Create(server,id); 
             this->data = (CameraData*)this->mMap; 
+            this->data->opened=false;
           }
 
   /// \brief Open an existing interface
@@ -613,8 +617,18 @@
           {
             Iface::Open(client,id); 
             this->data = (CameraData*)this->mMap; 
+            this->data->opened=true;
           }
 
+  /// \brief Close an existing interface
+  /// \param client Pointer to the client
+  /// \param id Id of the interface
+  public: virtual void Close()
+          {
+            Iface::Close();
+            this->data->opened=false;
+          }
+
   /// Pointer to the camera data
   public: CameraData *data;
 };
@@ -833,6 +847,9 @@
 
   /// Commaned range count
   public: int cmd_range_count;
+
+  /// is laser interface opened?
+  public: bool opened;
 };
 
 /// \brief Laser interface
@@ -851,6 +868,7 @@
           {
             Iface::Create(server,id); 
             this->data = (LaserData*)this->mMap; 
+            this->data->opened=false;
           }
 
   /// \brief Open an existing interface
@@ -860,8 +878,16 @@
           {
             Iface::Open(client,id); 
             this->data = (LaserData*)this->mMap; 
+            this->data->opened=true;
           }
 
+  /// \brief Close an existing interface
+  public: virtual void Close()
+          {
+            Iface::Close();
+            this->data->opened=false;
+          }
+
   /// Pointer to the laser data
   public: LaserData *data;
 };
@@ -1065,6 +1091,30 @@
 
   /// Lift down flag
   public: int lift_down;
+
+  /// Enable flag
+  public: int cmdEnableMotor;
+
+  /// Gripper Position Rate Command
+  public: float cmdPositionRate;
+  /// Gripper Force Command
+  public: float cmdForce;
+  /// Gripper Gap Command
+  public: float cmdGap;
+
+  /// Gripper force
+  public: double gripperForce;
+  /// Gripper controller gains
+  public: double pGain;
+  public: double dGain;
+  public: double iGain;
+
+  /// Position
+  public: float actualFingerPosition[2];
+  /// Position Rate
+  public: float actualFingerPositionRate[2];
+
+
 };
 
 /// \brief Gripper interface
@@ -1262,9 +1312,328 @@
 /// \} */
 
 
+
+
 /***************************************************************************/
 /// \addtogroup libgazebo_iface
 /// \{
+/** \defgroup gripper_iface gripper
+
+  \brief PR2 Gripper interface
+
+The gripper interface allows control of a simple pseudo-1-DOF PR2 gripper, such as
+that found on the Pioneer series robots.
+
+
+\{
+*/
+
+/** Gripper state: open */
+#define GAZEBO_PR2GRIPPER_STATE_OPEN 1
+/** Gripper state: closed */
+#define GAZEBO_PR2GRIPPER_STATE_CLOSED 2
+/** Gripper state: moving */
+#define GAZEBO_PR2GRIPPER_STATE_MOVING 3
+/** Gripper state: error */
+#define GAZEBO_PR2GRIPPER_STATE_ERROR 4
+
+/** Gripper command: open */
+#define GAZEBO_PR2GRIPPER_CMD_OPEN 1
+/** Gripper command: close */
+#define GAZEBO_PR2GRIPPER_CMD_CLOSE 2
+/** Gripper command: stop */
+#define GAZEBO_PR2GRIPPER_CMD_STOP 3
+/** Gripper command: store */
+#define GAZEBO_PR2GRIPPER_CMD_STORE 4
+/** Gripper command: retrieve */
+#define GAZEBO_PR2GRIPPER_CMD_RETRIEVE 5
+
+
+/// \brief Fudicial interface data
+class PR2GripperData
+{
+  public: GazeboData head;
+
+  /// \brief Current command for the gripper
+  public: int cmd;
+
+  /// Current state of the gripper
+  public: int state;
+
+  /// Gripped limit reached flag
+  public: int grip_limit_reach;
+
+  /// Lift limit reached flag
+  public: int lift_limit_reach;
+
+  /// Outer beam obstruct flag
+  public: int outer_beam_obstruct;
+
+  /// control mode, TODO: yet to be defined
+  public: int controlMode;
+
+  /// Inner beam obstructed flag
+  public: int inner_beam_obstruct;
+
+  /// Left paddle open flag
+  public: int left_paddle_open;
+
+  /// Right paddle open flag
+  public: int right_paddle_open;
+
+  /// Lift up flag
+  public: int lift_up;
+
+  /// Lift down flag
+  public: int lift_down;
+
+  /// Enable flag
+  public: int cmdEnableMotor;
+
+  /// Gripper Position Rate Command
+  public: float cmdPositionRate;
+  /// Gripper Force Command
+  public: float cmdForce;
+  /// Gripper Gap Command
+  public: float cmdGap;
+
+  /// Gripper force
+  public: double gripperForce;
+  /// Gripper controller gains
+  public: double pGain;
+  public: double dGain;
+  public: double iGain;
+
+  /// Position
+  public: float actualFingerPosition[2];
+  /// Position Rate
+  public: float actualFingerPositionRate[2];
+
+
+};
+
+/// \brief Gripper interface
+class PR2GripperIface : public Iface
+{
+  /// \brief Constructor
+  public: PR2GripperIface():Iface("pr2gripper", sizeof(PR2GripperIface)+sizeof(PR2GripperData)) {}
+
+  /// \brief Destructor
+  public: virtual ~PR2GripperIface() {this->data = NULL;}
+
+  /// \brief Create the server
+  public: virtual void Create(Server *server, std::string id)
+          {
+            Iface::Create(server,id); 
+            this->data = (PR2GripperData*)this->mMap; 
+          }
+
+  /// \brief Open the iface 
+  public: virtual void Open(Client *client, std::string id)
+          {
+            Iface::Open(client,id); 
+            this->data = (PR2GripperData*)this->mMap; 
+          }
+
+  /// Pointer to the gripper data
+  public: PR2GripperData *data;
+};
+
+/** \} */
+/// \}
+
+
+/***************************************************************************/
+/// \addtogroup libgazebo_iface 
+/// \{
+/** \defgroup pr2array_iface actarray
+
+  \brief PR2 Array
+
+The PR2 array interface allows a user to control a set of actuators.
+
+\{
+*/
+
+/// maximum number of actuators 
+#define GAZEBO_PR2ARRAY_MAX_NUM_ACTUATORS 64
+#define GAZEBO_PR2ARRAY_JOINT_POSITION_MODE 0
+#define GAZEBO_PR2ARRAY_JOINT_SPEED_MODE 1
+#define GAZEBO_PR2ARRAY_JOINT_CURRENT_MODE 2
+
+//Actuator states
+/// Idle state
+#define GAZEBO_PR2ARRAY_ACTSTATE_IDLE     1
+
+/// Moving state 
+#define GAZEBO_PR2ARRAY_ACTSTATE_MOVING   2
+
+/// Braked state 
+#define GAZEBO_PR2ARRAY_ACTSTATE_BRAKED   3
+
+/// Stalled state 
+#define GAZEBO_PR2ARRAY_ACTSTATE_STALLED  4
+
+/// Linear type 
+#define GAZEBO_PR2ARRAY_TYPE_LINEAR       1
+/// Rotary type
+#define GAZEBO_PR2ARRAY_TYPE_ROTARY       2
+
+/// Request subtype: power 
+#define GAZEBO_PR2ARRAY_POWER_REQ         1
+/// Request subtype: brakes 
+#define GAZEBO_PR2ARRAY_BRAKES_REQ        2
+/// Request subtype: get geometry 
+#define GAZEBO_PR2ARRAY_GET_GEOM_REQ      3
+/// Request subtype: speed
+#define GAZEBO_PR2ARRAY_SPEED_REQ         4
+
+/// Command subtype: position 
+#define GAZEBO_PR2ARRAY_POS_CMD           1
+/// Command subtype: speed 
+#define GAZEBO_PR2ARRAY_SPEED_CMD         2
+/// Command subtype: home 
+#define GAZEBO_PR2ARRAY_HOME_CMD          3
+
+
+/// \brief Actuator geometry 
+class PR2ArrayActuatorGeom
+{
+
+/// Data subtype: state
+#define GAZEBO_PR2ARRAY_DATA_STATE        1
+
+
+  /// The type of the actuator - linear or rotary.
+  public: uint8_t type;
+
+  /// Min range of motion (m or rad depending on the type)
+  public: float min;
+
+  /// Center position (m or rad)
+  public: float center;
+
+  /// Max range of motion (m or rad depending on the type)
+  public: float max;
+
+  /// Home position (m or rad depending on the type)
+  public: float home;
+
+  /// The configured speed - different from current speed. 
+  public: float config_speed;
+
+  /// The maximum achievable speed of the actuator.
+  public: float max_speed;
+
+  /// If the actuator has brakes or not. 
+  public: uint8_t hasbrakes;
+};
+
+/// \brief Structure containing a single actuator's information 
+class PR2ArrayActuator
+{
+  /// The position of the actuator in m or rad depending on the type.
+  public: float actualPosition;
+  /// The speed of the actuator in m/s or rad/s depending on the type. 
+  public: float actualSpeed;
+  /// The current state of the actuator. 
+  public: uint8_t state;
+}; 
+
+  typedef struct
+   {
+      double timestamp;
+      double actualPosition;
+      double actualSpeed;
+      double actualEffectorForce;
+
+      int controlMode;
+      int jointType;
+
+      double cmdPosition;
+      double cmdSpeed;
+      double cmdEffectorForce;
+
+      int cmdEnableMotor;
+
+      double pGain;
+      double iGain;
+      double dGain;
+      double iClamp;
+      double saturationTorque;
+      double dampingCoefficient;
+   } JointData;
+
+/// \brief The actuator array data packet. 
+class PR2ArrayData
+{
+  public: GazeboData head;
+
+  /// The number of actuators in the array. 
+  public: unsigned int actuators_count;
+  
+  /// The actuator data. 
+//  public: PR2ArrayActuator actuators[GAZEBO_PR2ARRAY_MAX_NUM_ACTUATORS];
+    public: JointData actuators[GAZEBO_PR2ARRAY_MAX_NUM_ACTUATORS];
+  
+  /// The actuators geoms 
+  public: PR2ArrayActuatorGeom actuator_geoms[GAZEBO_PR2ARRAY_MAX_NUM_ACTUATORS];
+  
+  /// position commands
+  public: float cmd_pos[GAZEBO_PR2ARRAY_MAX_NUM_ACTUATORS];
+  
+  /// speed commands
+  public: float cmd_speed[GAZEBO_PR2ARRAY_MAX_NUM_ACTUATORS];
+  
+  /// bad command flag - (speed to high set for the actuators or position not reachable)
+  public: int bad_cmd;
+
+  /// True if new command
+  public: bool new_cmd;
+  
+  /// position / speed comand
+  public: unsigned int joint_mode[GAZEBO_PR2ARRAY_MAX_NUM_ACTUATORS];
+  
+};
+
+/// \brief The PR2Array interface
+class PR2ArrayIface : public Iface
+{
+  /// \brief Create an interface
+  public: PR2ArrayIface():Iface("pr2array", sizeof(PR2ArrayIface)+sizeof(PR2ArrayData)) {}
+
+  /// \brief Destroy and Interface
+  public: virtual ~PR2ArrayIface() {this->data = NULL;}
+
+  /// \brief Create the interface (used by Gazebo server)
+  /// \param server Pointer to the server
+  /// \param id Id of the interface
+  public: virtual void Create(Server *server, std::string id)
+          {
+           Iface::Create(server,id); 
+           this->data = (PR2ArrayData*)this->mMap; 
+          }
+
+  /// \brief Open an existing interface
+  /// \param client Pointer to the client
+  /// \param id Id of the interface
+  public: virtual void Open(Client *client, std::string id)
+          {
+            Iface::Open(client,id); 
+            this->data = (PR2ArrayData*)this->mMap; 
+          }
+
+  /// Pointer to the act array data
+  public: PR2ArrayData *data;
+};
+
+/** \} */
+/// \} */
+
+
+/***************************************************************************/
+/// \addtogroup libgazebo_iface
+/// \{
 /** \defgroup ptz_iface ptz
 
   \brief PTZ interface
@@ -1342,7 +1711,7 @@
 \{
 */
 
-#define GAZEBO_STEREO_CAMERA_MAX_RGB_SIZE 640 * 480 * 3
+#define GAZEBO_STEREO_CAMERA_MAX_RGB_SIZE 640 * 480 * 9
 #define GAZEBO_STEREO_CAMERA_MAX_DISPARITY_SIZE 640 * 480
 
 /// \brief Stereo data
@@ -1380,6 +1749,9 @@
   /// Right depth map (float)
   public: float right_depth[GAZEBO_STEREO_CAMERA_MAX_DISPARITY_SIZE];
 
+  /// Is camera stream opened?
+  public: bool opened;
+  
 }; 
 
 
@@ -1397,6 +1769,7 @@
           {
             Iface::Create(server,id); 
             this->data = (StereoCameraData*)this->mMap; 
+            this->data->opened=false;
           }
 
   /// \brief Open the iface 
@@ -1404,8 +1777,16 @@
           {
             Iface::Open(client,id); 
             this->data = (StereoCameraData*)this->mMap; 
+            this->data->opened=true;
           }
 
+  /// \brief Close the iface 
+  public: virtual void Close()
+          {
+            Iface::Close();
+            this->data->opened=false;
+          }
+
   /// Pointer to the stereo data
   public: StereoCameraData *data;
 };
Index: server/physics/SphereGeom.cc
===================================================================
--- server/physics/SphereGeom.cc	(revision 6981)
+++ server/physics/SphereGeom.cc	(working copy)
@@ -55,10 +55,18 @@
   this->radiusP->Load(node);
 
   // Initialize box mass matrix
-  dMassSetSphereTotal(&this->mass, this->massP->GetValue(), this->radiusP->GetValue());
+  this->SetGeom( dCreateSphere(0, this->radiusP->GetValue()), true);
 
   // Create the sphere geometry
-  this->SetGeom( dCreateSphere(0, this->radiusP->GetValue()), true);
+  if (this->customMassMatrix)
+    dMassSetParameters(&this->mass, this->massP->GetValue(),
+           this->cx, this->cy, this->cz,
+           this->ixx,this->iyy,this->izz,
+           this->ixy,this->ixz,this->iyz);
+  else
+    dMassSetSphereTotal(&this->mass, this->massP->GetValue(), this->radiusP->GetValue());
+
+  
 }
 
 //////////////////////////////////////////////////////////////////////////////
Index: server/physics/BoxGeom.cc
===================================================================
--- server/physics/BoxGeom.cc	(revision 6981)
+++ server/physics/BoxGeom.cc	(working copy)
@@ -54,16 +54,25 @@
 {
   this->sizeP->Load(node);
 
-  // Initialize box mass matrix
-  dMassSetBoxTotal(&this->mass, this->massP->GetValue(),
-      this->sizeP->GetValue().x,
-      this->sizeP->GetValue().y,
-      this->sizeP->GetValue().z);
-
   // Create a box geometry with box mass matrix
   this->SetGeom(dCreateBox( 0, this->sizeP->GetValue().x, 
                             this->sizeP->GetValue().y,
                             this->sizeP->GetValue().z), true );
+
+  // Initialize box mass matrix
+  // set mass matrix if user provides some info
+  // pending a tag <massMatrix>true</massMatrix> in geom:
+  if (this->customMassMatrix)
+    dMassSetParameters(&this->mass, this->massP->GetValue(),
+           this->cx, this->cy, this->cz,
+           this->ixx,this->iyy,this->izz,
+           this->ixy,this->ixz,this->iyz);
+  else
+    dMassSetBoxTotal(&this->mass, this->massP->GetValue(),
+        this->sizeP->GetValue().x,
+        this->sizeP->GetValue().y,
+        this->sizeP->GetValue().z);
+
 }
 
 //////////////////////////////////////////////////////////////////////////////
Index: server/physics/Geom.hh
===================================================================
--- server/physics/Geom.hh	(revision 6981)
+++ server/physics/Geom.hh	(working copy)
@@ -168,6 +168,20 @@
     ///  Mass as a double
     protected: Param<double> *massP;
 
+    ///  User specified Mass Matrix
+    protected: Param<bool> *customMassMatrixP;
+    protected: Param<double> *cxP ;
+    protected: Param<double> *cyP ;
+    protected: Param<double> *czP ;
+    protected: Param<double> *ixxP;
+    protected: Param<double> *iyyP;
+    protected: Param<double> *izzP;
+    protected: Param<double> *ixyP;
+    protected: Param<double> *ixzP;
+    protected: Param<double> *iyzP;
+    protected: bool customMassMatrix;
+    protected: double cx,cy,cz,ixx,iyy,izz,ixy,ixz,iyz;
+
     private: Param<Vector3> *xyzP;
     private: Param<Quatern> *rpyP;
 
Index: server/physics/Body.hh
===================================================================
--- server/physics/Body.hh	(revision 6981)
+++ server/physics/Body.hh	(working copy)
@@ -170,6 +170,7 @@
   
     private: Param<Vector3> *xyzP;
     private: Param<Quatern> *rpyP;
+    private: Param<bool> *turnGravityOffP;
   };
   
   /// \}
Index: server/physics/HingeJoint.hh
===================================================================
--- server/physics/HingeJoint.hh	(revision 6981)
+++ server/physics/HingeJoint.hh	(working copy)
@@ -126,6 +126,7 @@
     private: Param<Vector3> *axisP;
     private: Param<Angle> *loStopP;
     private: Param<Angle> *hiStopP; 
+    private: Param<Vector3> *anchorOffsetP;
   };
   /// \}
   
Index: server/physics/CylinderGeom.cc
===================================================================
--- server/physics/CylinderGeom.cc	(revision 6981)
+++ server/physics/CylinderGeom.cc	(working copy)
@@ -51,13 +51,22 @@
 {
   this->sizeP->Load(node);
 
-  // Initialize mass matrix
-  dMassSetCylinderTotal(&this->mass, this->massP->GetValue(), 3, 
-      this->sizeP->GetValue().x, this->sizeP->GetValue().y);
-
+  // create a cylinder geometry
   this->SetGeom( dCreateCylinder( 0, this->sizeP->GetValue().x, 
         this->sizeP->GetValue().y ), true );
 
+  // Initialize mass matrix
+  // pending a tag <massMatrix>true</massMatrix> in geom:
+  if (this->customMassMatrix)
+    dMassSetParameters(&this->mass, this->massP->GetValue(),
+           this->cx, this->cy, this->cz,
+           this->ixx,this->iyy,this->izz,
+           this->ixy,this->ixz,this->iyz);
+  else
+    dMassSetCylinderTotal(&this->mass, this->massP->GetValue(), 3, 
+        this->sizeP->GetValue().x, this->sizeP->GetValue().y);
+
+
 }
 
 //////////////////////////////////////////////////////////////////////////////
Index: server/physics/Geom.cc
===================================================================
--- server/physics/Geom.cc	(revision 6981)
+++ server/physics/Geom.cc	(working copy)
@@ -66,6 +66,17 @@
   this->rpyP = new Param<Quatern>("rpy", Quatern(), 0);
   this->laserFiducialIdP = new Param<int>("laserFiducialId",-1,0);
   this->laserRetroP = new Param<float>("laserRetro",-1,0);
+
+  this->customMassMatrixP = new Param<bool>("massMatrix",false,0);
+  this->cxP = new Param<double>("cx",0.0,0);
+  this->cyP = new Param<double>("cy",0.0,0);
+  this->czP = new Param<double>("cz",0.0,0);
+  this->ixxP = new Param<double>("ixx",1e-6,0);
+  this->iyyP = new Param<double>("iyy",1e-6,0);
+  this->izzP = new Param<double>("izz",1e-6,0);
+  this->ixyP = new Param<double>("ixy",0.0,0);
+  this->ixzP = new Param<double>("ixz",0.0,0);
+  this->iyzP = new Param<double>("iyz",0.0,0);
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -91,6 +102,16 @@
   delete this->rpyP;
   delete this->laserFiducialIdP;
   delete this->laserRetroP;
+  delete this->customMassMatrixP;
+  delete this->cxP ;
+  delete this->cyP ;
+  delete this->czP ;
+  delete this->ixxP;
+  delete this->iyyP;
+  delete this->izzP;
+  delete this->ixyP;
+  delete this->ixzP;
+  delete this->iyzP;
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -115,6 +136,30 @@
     this->massP->SetValue( 0.001 );
   }
 
+  this->customMassMatrixP->Load(node);
+  this->cxP ->Load(node);
+  this->cyP ->Load(node);
+  this->czP ->Load(node);
+  this->ixxP->Load(node);
+  this->iyyP->Load(node);
+  this->izzP->Load(node);
+  this->ixyP->Load(node);
+  this->ixzP->Load(node);
+  this->iyzP->Load(node);
+
+  // option to enter full maxx matrix
+  this->customMassMatrix = this->customMassMatrixP->GetValue();
+  this->cx  = this->cxP ->GetValue();
+  this->cy  = this->cyP ->GetValue();
+  this->cz  = this->czP ->GetValue();
+  this->ixx = this->ixxP->GetValue();
+  this->iyy = this->iyyP->GetValue();
+  this->izz = this->izzP->GetValue();
+  this->ixy = this->ixyP->GetValue();
+  this->ixz = this->ixzP->GetValue();
+  this->iyz = this->iyzP->GetValue();
+
+
   this->contact->Load(node);
 
   this->LoadChild(node);
@@ -393,18 +438,21 @@
   if (!this->placeable)
     return NULL;
 
-  pose = this->GetPose();
+  pose = this->GetPose(); // get pose of the geometry
 
   q[0] = pose.rot.u;
   q[1] = pose.rot.x;
   q[2] = pose.rot.y;
   q[3] = pose.rot.z;
 
-  dQtoR(q,r);
+  dQtoR(q,r); // turn quaternion into rotation matrix
 
 
+  // this->mass was init to zero at start,
+  // read user specified mass into this->dblMass and dMassAdd in this->mass
   this->bodyMass = this->mass;
 
+
   if (dMassCheck(&this->bodyMass))
   {
     dMassRotate(&this->bodyMass, r);
Index: server/physics/Body.cc
===================================================================
--- server/physics/Body.cc	(revision 6981)
+++ server/physics/Body.cc	(working copy)
@@ -66,6 +66,7 @@
 
   this->xyzP = new Param<Vector3>("xyz", Vector3(), 0);
   this->rpyP = new Param<Quatern>("rpy", Quatern(), 0);
+  this->turnGravityOffP = new Param<bool>("turnGravityOff", false, 0);
 }
 
 
@@ -102,6 +103,7 @@
   this->nameP->Load(node);
   this->xyzP->Load(node);
   this->rpyP->Load(node);
+  this->turnGravityOffP->Load(node);
   Pose3d initPose;
 
   initPose.pos = **(this->xyzP);
@@ -129,8 +131,9 @@
   }
 
   // If no geoms are attached, then don't let gravity affect the body.
-  if (this->geoms.size()==0)
+  if (this->turnGravityOffP->GetValue() || this->geoms.size()==0)
   {
+    std::cout << "setting gravity to zero for: " << this->nameP->GetValue() << std::endl;
     this->SetGravityMode(false);
   }
 
Index: server/physics/HingeJoint.cc
===================================================================
--- server/physics/HingeJoint.cc	(revision 6981)
+++ server/physics/HingeJoint.cc	(working copy)
@@ -43,6 +43,7 @@
   this->axisP = new Param<Vector3>("axis",Vector3(0,1,0), 1);
   this->loStopP = new Param<Angle>("lowStop",-M_PI,0);
   this->hiStopP = new Param<Angle>("highStop",M_PI,0);
+  this->anchorOffsetP = new Param<Vector3>("anchorOffset",Vector3(0,0,0),0);
 }
 
 
@@ -62,6 +63,7 @@
   this->axisP->Load(node);
   this->loStopP->Load(node);
   this->hiStopP->Load(node);
+  this->anchorOffsetP->Load(node);
 
   // Perform this three step ordering to ensure the parameters are set
   // properly. This is taken from the ODE wiki.
@@ -131,7 +133,7 @@
 // Set the anchor point
 void HingeJoint::SetAnchor( const Vector3 &anchor )
 {
-  dJointSetHingeAnchor( this->jointId, anchor.x, anchor.y, anchor.z );
+  dJointSetHingeAnchor( this->jointId, anchor.x+anchorOffsetP->GetValue().x, anchor.y+anchorOffsetP->GetValue().y, anchor.z+anchorOffsetP->GetValue().z );
 }
 
 
Index: server/physics/ode/ODEPhysics.hh
===================================================================
--- server/physics/ode/ODEPhysics.hh	(revision 6981)
+++ server/physics/ode/ODEPhysics.hh	(working copy)
@@ -133,6 +133,7 @@
 
   private: Param<double> *globalCFMP; 
   private: Param<double> *globalERPP; 
+  private: Param<bool> *quickStepP; 
 };
 
 /** \}*/
Index: server/physics/ode/ODEPhysics.cc
===================================================================
--- server/physics/ode/ODEPhysics.cc	(revision 6981)
+++ server/physics/ode/ODEPhysics.cc	(working copy)
@@ -69,6 +69,7 @@
 
   this->globalCFMP = new Param<double>("cfm", 10e-5, 0);
   this->globalERPP = new Param<double>("erp", 0.2, 0);
+  this->quickStepP = new Param<bool>("quickStep", false, 0);
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -86,6 +87,7 @@
 
   delete this->globalCFMP;
   delete this->globalERPP;
+  delete this->quickStepP;
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -101,6 +103,7 @@
   this->updateRateP->Load(cnode);
   this->globalCFMP->Load(cnode);
   this->globalERPP->Load(cnode);
+  this->quickStepP->Load(cnode);
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -113,6 +116,7 @@
   stream << prefix << "  " << *(this->updateRateP) << "\n";
   stream << prefix << "  " << *(this->globalCFMP) << "\n";
   stream << prefix << "  " << *(this->globalERPP) << "\n";
+  stream << prefix << "  " << *(this->quickStepP) << "\n";
   stream << prefix << "</physics:ode>\n";
 }
 
@@ -135,8 +139,10 @@
   dSpaceCollide( this->spaceId, this, CollisionCallback );
 
   // Update the dynamical model
-  dWorldStep( this->worldId, this->stepTimeP->GetValue() );
-  //dWorldQuickStep(this->worldId, this->stepTime);
+  if (this->quickStepP->GetValue())
+    dWorldQuickStep(this->worldId, this->stepTimeP->GetValue() );
+  else
+    dWorldStep( this->worldId, this->stepTimeP->GetValue() );
 
   // Very important to clear out the contact group
   dJointGroupEmpty( this->contactGroup );
@@ -264,15 +270,16 @@
         contact.surface.mode = dContactSlip1 | dContactSlip2 | 
                                dContactSoftERP | dContactSoftCFM |  
                                dContactBounce | dContactMu2 | dContactApprox1;
+        contact.surface.mode = 0;
 
 
         // Compute the CFM and ERP by assuming the two bodies form a
         // spring-damper system.
         h = self->stepTimeP->GetValue();
-        kp = 1 / (1 / geom1->contact->kp + 1 / geom2->contact->kp);
+        kp = 1.0 / (1.0 / geom1->contact->kp + 1.0 / geom2->contact->kp);
         kd = geom1->contact->kd + geom2->contact->kd;
         contact.surface.soft_erp = h * kp / (h * kp + kd);
-        contact.surface.soft_cfm = 1 / (h * kp + kd);
+        contact.surface.soft_cfm = 1.0 / (h * kp + kd);
 
         contact.surface.mu = MIN(geom1->contact->mu1, geom2->contact->mu1);
         contact.surface.mu2 = MIN(geom1->contact->mu2, geom2->contact->mu2);
Index: server/physics/TrimeshGeom.cc
===================================================================
--- server/physics/TrimeshGeom.cc	(revision 6981)
+++ server/physics/TrimeshGeom.cc	(working copy)
@@ -206,7 +206,13 @@
 
   this->geomId = dCreateTriMesh( this->spaceId, this->odeData,0,0,0 );
 
-  dMassSetTrimesh(&this->mass, this->massP->GetValue(), this->geomId);
+  if (this->customMassMatrix)
+    dMassSetParameters(&this->mass, this->massP->GetValue(),
+         this->cx, this->cy, this->cz,
+         this->ixx,this->iyy,this->izz,
+         this->ixy,this->ixz,this->iyz);
+  else
+    dMassSetTrimesh(&this->mass, this->massP->GetValue(), this->geomId);
 
   // Create the trimesh geometry
   this->SetGeom(this->geomId, true);
Index: server/sensors/Sensor.hh
===================================================================
--- server/sensors/Sensor.hh	(revision 6981)
+++ server/sensors/Sensor.hh	(working copy)
@@ -70,6 +70,7 @@
 
     /// \brief Set whether the sensor is active or not
     public: void SetActive(bool value);
+    public: bool IsActive();
 
     /// \brief  Load the child sensor
     protected: virtual void LoadChild(XMLConfigNode * /*node*/) {};
@@ -101,7 +102,6 @@
     protected: double lastUpdate;
     protected: std::string typeName;
   };
-  
   /// \}
 }
 #endif
Index: server/sensors/ray/RaySensor.cc
===================================================================
--- server/sensors/ray/RaySensor.cc	(revision 6981)
+++ server/sensors/ray/RaySensor.cc	(working copy)
@@ -271,7 +271,7 @@
 // Update the sensor information
 void RaySensor::UpdateChild()
 {
-//  if (this->active)
+  if (this->active)
   {
     std::vector<RayGeom*>::iterator iter;
     Pose3d poseDelta;
Index: server/sensors/Sensor.cc
===================================================================
--- server/sensors/Sensor.cc	(revision 6981)
+++ server/sensors/Sensor.cc	(working copy)
@@ -33,6 +33,7 @@
 #include "ControllerFactory.hh"
 #include "Simulator.hh"
 #include "Sensor.hh"
+#include "Simulator.hh"
 
 using namespace gazebo;
 
@@ -69,6 +70,14 @@
 
   this->LoadController( node->GetChildByNSPrefix("controller") );
   this->LoadChild(node);
+
+  double updateRate  = node->GetDouble("updateRate", 0, 0);
+  if (updateRate == 0)
+    this->updatePeriod = 0.0; // no throttling if updateRate is 0
+  else
+    this->updatePeriod = 1.0 / updateRate;
+  this->lastUpdate   = Simulator::Instance()->GetSimTime();
+
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -183,4 +192,11 @@
   this->active = value;
 }
 
+////////////////////////////////////////////////////////////////////////////////
+/// \brief Set whether the sensor is active or not
+bool Sensor::IsActive()
+{
+  return this->active;
+}
 
+
Index: server/Simulator.cc
===================================================================
--- server/Simulator.cc	(revision 6981)
+++ server/Simulator.cc	(working copy)
@@ -72,6 +72,7 @@
   timeout(-1),
   selectedEntity(NULL)
 {
+  selectedEntity = NULL;
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -291,6 +292,9 @@
   {
     currTime = this->GetRealTime();
 
+    //double tmpT1 = this->GetWallTime();
+    //fprintf(stderr, " before World::Instance()->Update() sim: %.5f t %.5f",this->simTime ,  tmpT1);
+
     if (physicsUpdateRate == 0 || 
         currTime - this->prevPhysicsTime >= physicsUpdatePeriod) 
     {
@@ -315,6 +319,9 @@
       this->prevPhysicsTime = this->GetRealTime();
     }
 
+    //double tmpT2 = this->GetWallTime();
+    //fprintf(stderr, " world dt %.5f",tmpT2-tmpT1);
+
     // Update the rendering
     if (renderUpdateRate == 0 || 
         currTime - this->prevRenderTime >= renderUpdatePeriod)
Index: server/GazeboConfig.cc
===================================================================
--- server/GazeboConfig.cc	(revision 6981)
+++ server/GazeboConfig.cc	(working copy)
@@ -67,31 +67,34 @@
     this->gazeboPaths.push_back(gazebo_resource_path);
   }
 
-  // if both paths are set, don't check the config file or use the defaults.
-  if(ogre_resource_path && gazebo_resource_path) 
-    return;
-
-
   if (cfgFile)
   {
     XMLConfig rc;
     XMLConfigNode *node;
     rc.Load(rcFilename);
 
-    node = rc.GetRootNode()->GetChild("gazeboPath");
-    while (node)
+    // if gazebo path is set, skip reading from .gazeborc
+    if(!gazebo_resource_path)
     {
-      gzmsg(1) << "Gazebo Path[" << node->GetValue() << "]\n";
-      this->gazeboPaths.push_back(node->GetValue());
-      node = node->GetNext("gazeboPath");
+      node = rc.GetRootNode()->GetChild("gazeboPath");
+      while (node)
+      {
+        gzmsg(1) << "Gazebo Path[" << node->GetValue() << "]\n";
+        this->gazeboPaths.push_back(node->GetValue());
+        node = node->GetNext("gazeboPath");
+      }
     }
 
-    node = rc.GetRootNode()->GetChild("ogrePath");
-    while (node)
+    // if ogre path is set, skip reading from .gazeborc
+    if(!ogre_resource_path)
     {
-      gzmsg(1) << "Ogre Path[" << node->GetValue() << "]\n";
-      this->ogrePaths.push_back( node->GetValue() );
-      node = node->GetNext("ogrePath");
+      node = rc.GetRootNode()->GetChild("ogrePath");
+      while (node)
+      {
+        gzmsg(1) << "Ogre Path[" << node->GetValue() << "]\n";
+        this->ogrePaths.push_back( node->GetValue() );
+        node = node->GetNext("ogrePath");
+      }
     }
     this->RTTMode = rc.GetRootNode()->GetString("RTTMode", "PBuffer");
 
@@ -99,9 +102,18 @@
   else
   {
     gzmsg(0) << "Unable to find the file ~/.gazeborc. Using default paths. This may cause OGRE to fail.\n";
-    this->gazeboPaths.push_back("/usr/local/share/gazebo");
-    this->ogrePaths.push_back("/usr/local/lib/OGRE");
-    this->ogrePaths.push_back("/usr/lib/OGRE");
+
+    if ( !gazebo_resource_path )
+    {
+	this->gazeboPaths.push_back("/usr/local/share/gazebo");
+    }
+
+    if ( !ogre_resource_path )
+    {
+	this->ogrePaths.push_back("/usr/local/lib/OGRE");
+	this->ogrePaths.push_back("/usr/lib/OGRE");
+    }
+
     this->RTTMode="PBuffer";
   }
 }
Index: server/gui/GLWindow.cc
===================================================================
--- server/gui/GLWindow.cc	(revision 6981)
+++ server/gui/GLWindow.cc	(working copy)
@@ -227,21 +227,10 @@
     }
     else if (this->rightMousePressed)
     {
-      Model *model = dynamic_cast<Model*>(Simulator::Instance()->GetSelectedEntity());
-      if (model)
-      {
-        Pose3d pose = model->GetPose();
-        pose.pos.y -= d.x * 0.05;
-        pose.pos.x -= d.y * 0.05;
-        model->SetPose(pose);
-      }
-      else
-      {
-        Vector2<int> d = this->mousePos - this->prevMousePos;
-        this->directionVec.x = 0;
-        this->directionVec.y =  d.x * this->moveAmount;
-        this->directionVec.z =  d.y * this->moveAmount;
-      }
+      Vector2<int> d = this->mousePos - this->prevMousePos;
+      this->directionVec.x = 0;
+      this->directionVec.y =  d.x * this->moveAmount;
+      this->directionVec.z =  d.y * this->moveAmount;
     }
     else if (this->middleMousePressed)
     {
Index: server/World.hh
===================================================================
--- server/World.hh	(revision 6981)
+++ server/World.hh	(working copy)
@@ -92,6 +92,26 @@
   /// \return Pointer to the physics engine
   public: PhysicsEngine *GetPhysicsEngine() const;
 
+  /// Get the simulation time
+  /// \return The simulation time
+  public: double GetSimTime() const;
+
+  /// Get the pause time
+  /// \return The pause time
+  public: double GetPauseTime() const;
+
+  /// Get the start time
+  /// \return The start time
+  public: double GetStartTime() const;
+
+  /// Get the real time (elapsed time)
+  /// \return The real time
+  public: double GetRealTime() const;
+
+  /// \brief Get the wall clock time
+  /// \return The wall clock time
+  public: double GetWallTime() const;
+
   /// \brief Load all entities
   /// \param node XMLConfg node pointer
   /// \param parent Parent of the model to load
@@ -186,6 +206,9 @@
   /// Simulation interface
   private: SimulationIface *simIface;
 
+  /// Current simulation time
+  private: double simTime, pauseTime, startTime;
+
   private: friend class DestroyerT<World>;
   private: friend class SingletonT<World>;
 };
Index: server/controllers/camera/generic/Generic_Camera.cc
===================================================================
--- server/controllers/camera/generic/Generic_Camera.cc	(revision 6981)
+++ server/controllers/camera/generic/Generic_Camera.cc	(working copy)
@@ -86,7 +86,24 @@
 // Update the controller
 void Generic_Camera::UpdateChild()
 {
-  this->PutCameraData();
+
+  // do this first so there's chance for sensor to run 1 frame after activate
+  if (this->myParent->IsActive())
+    this->PutCameraData();
+
+  // activate if iface open
+  if (this->cameraIface->Lock(1))
+  {
+    if (this->cameraIface->GetOpenCount() > 0)
+      this->myParent->SetActive(true);
+    else
+      this->myParent->SetActive(false);
+
+    //std::cout << " camera open count " << this->cameraIface->GetOpenCount() << std::endl;
+    this->cameraIface->Unlock();
+  }
+  //std::cout << " camera     active " << this->myParent->IsActive() << std::endl;
+
 }
 
 ////////////////////////////////////////////////////////////////////////////////
Index: server/controllers/Controller.cc
===================================================================
--- server/controllers/Controller.cc	(revision 6981)
+++ server/controllers/Controller.cc	(working copy)
@@ -73,11 +73,15 @@
   this->typeName = node->GetName();
 
   this->nameP->Load(node);
+
   this->updatePeriodP->Load(node);
-  this->updatePeriod = 1.0 / (this->updatePeriodP->GetValue() + 1e-6);
+  double updateRate  = this->updatePeriodP->GetValue();
+  if (updateRate == 0)
+    this->updatePeriod = 0.0; // no throttling if updateRate is 0
+  else
+    this->updatePeriod = 1.0 / updateRate;
+  this->lastUpdate   = Simulator::Instance()->GetSimTime();
 
-  this->lastUpdate = -1e6;
-
   childNode = node->GetChildByNSPrefix("interface");
 
   // Create the interfaces
Index: server/controllers/ptz/generic/Generic_PTZ.cc
===================================================================
--- server/controllers/ptz/generic/Generic_PTZ.cc	(revision 6981)
+++ server/controllers/ptz/generic/Generic_PTZ.cc	(working copy)
@@ -68,10 +68,10 @@
 // Destructor
 Generic_PTZ::~Generic_PTZ()
 {
-  if (this->panJoint)
-    delete this->panJoint;
-  if (this->tiltJoint)
-    delete this->tiltJoint;
+  //if (this->panJoint)
+  //  delete this->panJoint;
+  //if (this->tiltJoint)
+  //  delete this->tiltJoint;
 
   this->panJoint = NULL;
   this->tiltJoint = NULL;
Index: server/World.cc
===================================================================
--- server/World.cc	(revision 6981)
+++ server/World.cc	(working copy)
@@ -27,6 +27,7 @@
 #include <assert.h>
 #include <sstream>
 #include <fstream>
+#include <sys/time.h> //gettimeofday
 
 #include "Global.hh"
 #include "GazeboError.hh"
@@ -57,6 +58,9 @@
   this->server = NULL;
   this->simIface = NULL;
 
+  this->simTime = 0.0;
+  this->pauseTime = 0.0;
+  this->startTime = 0.0;
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -172,6 +176,7 @@
 
   this->physicsEngine->Init();
 
+  this->startTime = this->GetWallTime();
   this->toAddModels.clear();
   this->toDeleteModels.clear();
 
@@ -185,6 +190,11 @@
   std::vector< Model* >::iterator miter;
   std::vector< Model* >::iterator miter2;
 
+  this->simTime += this->physicsEngine->GetStepTime();
+
+  //double tmpT1 = this->GetWallTime();
+  //fprintf(stderr, " | sim ");
+
   // Update all the models
   for (miter=this->models.begin(); miter!=this->models.end(); miter++)
   {
@@ -194,14 +204,27 @@
     }
   }
 
+  //double tmpT2 = this->GetWallTime();
+  //fprintf(stderr, " model dt: %.5f",tmpT2-tmpT1);
+
   if (!Simulator::Instance()->IsPaused() &&
        Simulator::Instance()->GetPhysicsEnabled())
   {
     this->physicsEngine->Update();
   }
+  else
+  {
+    this->pauseTime += this->physicsEngine->GetStepTime();
+  }
 
+  //double tmpT3 = this->GetWallTime();
+  //fprintf(stderr, " physics dt: %.5f",tmpT3-tmpT2);
+
   this->UpdateSimulationIface();
 
+  //double tmpT4 = this->GetWallTime();
+  //fprintf(stderr, " Iface dt: %.5f",tmpT4-tmpT3);
+
   // Copy the newly created models into the main model vector
   std::copy(this->toAddModels.begin(), this->toAddModels.end(),
             std::back_inserter(this->models));
@@ -219,6 +242,9 @@
 
   this->toDeleteModels.clear();
 
+  //double tmpT5 = this->GetWallTime();
+  //fprintf(stderr, " add/del models dt: %.5f | ",tmpT5-tmpT4);
+
   return 0;
 }
 
@@ -273,6 +299,41 @@
   return this->physicsEngine;
 }
 
+////////////////////////////////////////////////////////////////////////////////
+// Get the simulation time
+double World::GetSimTime() const
+{
+  return this->simTime;
+}
+////////////////////////////////////////////////////////////////////////////////
+// Get the pause time
+double World::GetPauseTime() const
+{
+  return this->pauseTime;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+/// Get the start time
+double World::GetStartTime() const
+{
+  return this->startTime;
+}
+////////////////////////////////////////////////////////////////////////////////
+/// Get the real time (elapsed time)
+double World::GetRealTime() const
+{
+  return this->GetWallTime() - this->startTime;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+/// Get the wall clock time
+double World::GetWallTime() const
+{
+  struct timeval tv;
+  gettimeofday(&tv, NULL);
+  return tv.tv_sec + tv.tv_usec * 1e-6;
+}
+
 ///////////////////////////////////////////////////////////////////////////////
 // Load a model
 int World::LoadEntities(XMLConfigNode *node, Model *parent)
Index: SConstruct
===================================================================
--- SConstruct	(revision 6981)
+++ SConstruct	(working copy)
@@ -22,8 +22,9 @@
 # 3rd party packages
 #
 parseConfigs=['pkg-config --cflags --libs OGRE',
+              'pkg-config --cflags --libs freeimage', 
               'xml2-config --cflags --libs', 
-      	      'ode-config --cflags --libs',
+              'ode-config --cflags --libs', 
               'fltk-config --cflags --libs --ldflags --use-gl --use-images',
               'pkg-config --cflags --libs xft'
               ]
@@ -80,7 +81,7 @@
 rcconfig = env.RCConfig(target='gazeborc', source=Value(install_prefix))
 
 # DEFAULT list of subdirectories to build
-subdirs = ['libgazebo','server', 'player']
+subdirs = ['libgazebo','server']
 
 # Set the compile mode
 if env['mode'] == 'debug':
