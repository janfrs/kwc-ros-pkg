Index: player/SConscript
===================================================================
--- player/SConscript	(revision 7016)
+++ player/SConscript	(working copy)
@@ -1,7 +1,8 @@
 import os
 Import('env install_prefix sharedObjs subdirs')
 
-parseConfigs = ['pkg-config --cflags --libs playerc++']
+parseConfigs = ['pkg-config --cflags --libs playerc++',
+                'pkg-config --cflags --libs playerc']
 
 sources = ['GazeboDriver.cc',
            'GazeboClient.cc',
Index: libgazebo/gazebo.h
===================================================================
--- libgazebo/gazebo.h	(revision 7016)
+++ libgazebo/gazebo.h	(working copy)
@@ -556,7 +556,7 @@
 
 
 /// Maximum image pixels (width x height)
-#define GAZEBO_CAMERA_MAX_IMAGE_SIZE 640 * 480 * 3
+#define GAZEBO_CAMERA_MAX_IMAGE_SIZE 1024 * 1024 * 3
 
 /// \brief Camera interface data
 class CameraData
@@ -584,6 +584,9 @@
   /// Pose of the camera
   public: Pose camera_pose;
   
+  /// Is camera stream opened?
+  public: bool opened;
+  
 };
 
 /// \brief The camera interface
@@ -602,6 +605,7 @@
           {
             Iface::Create(server,id); 
             this->data = (CameraData*)this->mMap; 
+            this->data->opened=false;
           }
 
   /// \brief Open an existing interface
@@ -611,8 +615,18 @@
           {
             Iface::Open(client,id); 
             this->data = (CameraData*)this->mMap; 
+            this->data->opened=true;
           }
 
+  /// \brief Close an existing interface
+  /// \param client Pointer to the client
+  /// \param id Id of the interface
+  public: virtual void Close()
+          {
+            Iface::Close();
+            this->data->opened=false;
+          }
+
   /// Pointer to the camera data
   public: CameraData *data;
 };
@@ -831,6 +845,9 @@
 
   /// Commaned range count
   public: int cmd_range_count;
+
+  /// is laser interface opened?
+  public: bool opened;
 };
 
 /// \brief Laser interface
@@ -849,6 +866,7 @@
           {
             Iface::Create(server,id); 
             this->data = (LaserData*)this->mMap; 
+            this->data->opened=false;
           }
 
   /// \brief Open an existing interface
@@ -858,8 +876,16 @@
           {
             Iface::Open(client,id); 
             this->data = (LaserData*)this->mMap; 
+            this->data->opened=true;
           }
 
+  /// \brief Close an existing interface
+  public: virtual void Close()
+          {
+            Iface::Close();
+            this->data->opened=false;
+          }
+
   /// Pointer to the laser data
   public: LaserData *data;
 };
@@ -1063,6 +1089,30 @@
 
   /// Lift down flag
   public: int lift_down;
+
+  /// Enable flag
+  public: int cmdEnableMotor;
+
+  /// Gripper Position Rate Command
+  public: float cmdPositionRate;
+  /// Gripper Force Command
+  public: float cmdForce;
+  /// Gripper Gap Command
+  public: float cmdGap;
+
+  /// Gripper force
+  public: double gripperForce;
+  /// Gripper controller gains
+  public: double pGain;
+  public: double dGain;
+  public: double iGain;
+
+  /// Position
+  public: float actualFingerPosition[2];
+  /// Position Rate
+  public: float actualFingerPositionRate[2];
+
+
 };
 
 /// \brief Gripper interface
@@ -1260,6 +1310,8 @@
 /// \} */
 
 
+
+
 /***************************************************************************/
 /// \addtogroup libgazebo_iface
 /// \{
@@ -1340,7 +1392,7 @@
 \{
 */
 
-#define GAZEBO_STEREO_CAMERA_MAX_RGB_SIZE 640 * 480 * 3
+#define GAZEBO_STEREO_CAMERA_MAX_RGB_SIZE 640 * 480 * 9
 #define GAZEBO_STEREO_CAMERA_MAX_DISPARITY_SIZE 640 * 480
 
 /// \brief Stereo data
@@ -1378,6 +1430,9 @@
   /// Right depth map (float)
   public: float right_depth[GAZEBO_STEREO_CAMERA_MAX_DISPARITY_SIZE];
 
+  /// Is camera stream opened?
+  public: bool opened;
+  
 }; 
 
 
@@ -1395,6 +1450,7 @@
           {
             Iface::Create(server,id); 
             this->data = (StereoCameraData*)this->mMap; 
+            this->data->opened=false;
           }
 
   /// \brief Open the iface 
@@ -1402,8 +1458,16 @@
           {
             Iface::Open(client,id); 
             this->data = (StereoCameraData*)this->mMap; 
+            this->data->opened=true;
           }
 
+  /// \brief Close the iface 
+  public: virtual void Close()
+          {
+            Iface::Close();
+            this->data->opened=false;
+          }
+
   /// Pointer to the stereo data
   public: StereoCameraData *data;
 };
Index: server/physics/SphereGeom.cc
===================================================================
--- server/physics/SphereGeom.cc	(revision 7016)
+++ server/physics/SphereGeom.cc	(working copy)
@@ -66,11 +66,18 @@
   this->radiusP->SetValue( radius );
 
   // Initialize box mass matrix
-  dMassSetSphereTotal(&this->mass, this->massP->GetValue(), 
-                      this->radiusP->GetValue());
+  this->SetGeom( dCreateSphere(0, this->radiusP->GetValue()), true);
 
   // Create the sphere geometry
-  this->SetGeom( dCreateSphere(0, this->radiusP->GetValue()), true);
+  if (this->customMassMatrix)
+    dMassSetParameters(&this->mass, this->massP->GetValue(),
+           this->cx, this->cy, this->cz,
+           this->ixx,this->iyy,this->izz,
+           this->ixy,this->ixz,this->iyz);
+  else
+    dMassSetSphereTotal(&this->mass, this->massP->GetValue(), this->radiusP->GetValue());
+
+  
 }
 
 ////////////////////////////////////////////////////////////////////////////////
Index: server/physics/BoxGeom.cc
===================================================================
--- server/physics/BoxGeom.cc	(revision 7016)
+++ server/physics/BoxGeom.cc	(working copy)
@@ -66,9 +66,18 @@
   this->sizeP->SetValue( size );
 
   // Initialize box mass matrix
-  dMassSetBoxTotal(&this->mass, this->massP->GetValue(), 
-      this->sizeP->GetValue().x, this->sizeP->GetValue().y, 
-      this->sizeP->GetValue().z);
+  // set mass matrix if user provides some info
+  // pending a tag <massMatrix>true</massMatrix> in geom:
+  if (this->customMassMatrix)
+    dMassSetParameters(&this->mass, this->massP->GetValue(),
+           this->cx, this->cy, this->cz,
+           this->ixx,this->iyy,this->izz,
+           this->ixy,this->ixz,this->iyz);
+  else
+    // Initialize box mass matrix
+    dMassSetBoxTotal(&this->mass, this->massP->GetValue(), 
+        this->sizeP->GetValue().x, this->sizeP->GetValue().y, 
+        this->sizeP->GetValue().z);
 
 
   // Create a box geometry with box mass matrix
Index: server/physics/Geom.hh
===================================================================
--- server/physics/Geom.hh	(revision 7016)
+++ server/physics/Geom.hh	(working copy)
@@ -171,6 +171,20 @@
     ///  Mass as a double
     protected: ParamT<double> *massP;
 
+    ///  User specified Mass Matrix
+    protected: ParamT<bool> *customMassMatrixP;
+    protected: ParamT<double> *cxP ;
+    protected: ParamT<double> *cyP ;
+    protected: ParamT<double> *czP ;
+    protected: ParamT<double> *ixxP;
+    protected: ParamT<double> *iyyP;
+    protected: ParamT<double> *izzP;
+    protected: ParamT<double> *ixyP;
+    protected: ParamT<double> *ixzP;
+    protected: ParamT<double> *iyzP;
+    protected: bool customMassMatrix;
+    protected: double cx,cy,cz,ixx,iyy,izz,ixy,ixz,iyz;
+
     private: ParamT<Vector3> *xyzP;
     private: ParamT<Quatern> *rpyP;
 
Index: server/physics/Body.hh
===================================================================
--- server/physics/Body.hh	(revision 7016)
+++ server/physics/Body.hh	(working copy)
@@ -180,6 +180,7 @@
   
     private: ParamT<Vector3> *xyzP;
     private: ParamT<Quatern> *rpyP;
+    private: ParamT<bool> *turnGravityOffP;
   };
   
   /// \}
Index: server/physics/HingeJoint.hh
===================================================================
--- server/physics/HingeJoint.hh	(revision 7016)
+++ server/physics/HingeJoint.hh	(working copy)
@@ -126,6 +126,7 @@
     private: ParamT<Vector3> *axisP;
     private: ParamT<Angle> *loStopP;
     private: ParamT<Angle> *hiStopP; 
+    private: ParamT<Vector3> *anchorOffsetP;
   };
   /// \}
   
Index: server/physics/CylinderGeom.cc
===================================================================
--- server/physics/CylinderGeom.cc	(revision 7016)
+++ server/physics/CylinderGeom.cc	(working copy)
@@ -64,11 +64,21 @@
   this->sizeP->SetValue( size );
 
   // Initialize mass matrix
-  dMassSetCylinderTotal(&this->mass, this->massP->GetValue(), 3, 
-      this->sizeP->GetValue().x, this->sizeP->GetValue().y);
+  // pending a tag <massMatrix>true</massMatrix> in geom:
+  if (this->customMassMatrix)
+    dMassSetParameters(&this->mass, this->massP->GetValue(),
+           this->cx, this->cy, this->cz,
+           this->ixx,this->iyy,this->izz,
+           this->ixy,this->ixz,this->iyz);
+  else
+    // Initialize mass matrix
+    dMassSetCylinderTotal(&this->mass, this->massP->GetValue(), 3, 
+        this->sizeP->GetValue().x, this->sizeP->GetValue().y);
 
   this->SetGeom( dCreateCylinder( 0, this->sizeP->GetValue().x, 
         this->sizeP->GetValue().y ), true );
+
+
 }
 
 //////////////////////////////////////////////////////////////////////////////
Index: server/physics/Geom.cc
===================================================================
--- server/physics/Geom.cc	(revision 7016)
+++ server/physics/Geom.cc	(working copy)
@@ -73,6 +73,17 @@
 
   this->laserFiducialIdP = new ParamT<int>("laserFiducialId",-1,0);
   this->laserRetroP = new ParamT<float>("laserRetro",-1,0);
+
+  this->customMassMatrixP = new ParamT<bool>("massMatrix",false,0);
+  this->cxP = new ParamT<double>("cx",0.0,0);
+  this->cyP = new ParamT<double>("cy",0.0,0);
+  this->czP = new ParamT<double>("cz",0.0,0);
+  this->ixxP = new ParamT<double>("ixx",1e-6,0);
+  this->iyyP = new ParamT<double>("iyy",1e-6,0);
+  this->izzP = new ParamT<double>("izz",1e-6,0);
+  this->ixyP = new ParamT<double>("ixy",0.0,0);
+  this->ixzP = new ParamT<double>("ixz",0.0,0);
+  this->iyzP = new ParamT<double>("iyz",0.0,0);
   Param::End();
 }
 
@@ -99,6 +110,16 @@
   delete this->rpyP;
   delete this->laserFiducialIdP;
   delete this->laserRetroP;
+  delete this->customMassMatrixP;
+  delete this->cxP ;
+  delete this->cyP ;
+  delete this->czP ;
+  delete this->ixxP;
+  delete this->iyyP;
+  delete this->izzP;
+  delete this->ixyP;
+  delete this->ixzP;
+  delete this->iyzP;
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -123,6 +144,30 @@
     this->massP->SetValue( 0.001 );
   }
 
+  this->customMassMatrixP->Load(node);
+  this->cxP ->Load(node);
+  this->cyP ->Load(node);
+  this->czP ->Load(node);
+  this->ixxP->Load(node);
+  this->iyyP->Load(node);
+  this->izzP->Load(node);
+  this->ixyP->Load(node);
+  this->ixzP->Load(node);
+  this->iyzP->Load(node);
+
+  // option to enter full maxx matrix
+  this->customMassMatrix = this->customMassMatrixP->GetValue();
+  this->cx  = this->cxP ->GetValue();
+  this->cy  = this->cyP ->GetValue();
+  this->cz  = this->czP ->GetValue();
+  this->ixx = this->ixxP->GetValue();
+  this->iyy = this->iyyP->GetValue();
+  this->izz = this->izzP->GetValue();
+  this->ixy = this->ixyP->GetValue();
+  this->ixz = this->ixzP->GetValue();
+  this->iyz = this->iyzP->GetValue();
+
+
   this->contact->Load(node);
 
   this->LoadChild(node);
@@ -401,18 +446,21 @@
   if (!this->placeable)
     return NULL;
 
-  pose = this->GetPose();
+  pose = this->GetPose(); // get pose of the geometry
 
   q[0] = pose.rot.u;
   q[1] = pose.rot.x;
   q[2] = pose.rot.y;
   q[3] = pose.rot.z;
 
-  dQtoR(q,r);
+  dQtoR(q,r); // turn quaternion into rotation matrix
 
 
+  // this->mass was init to zero at start,
+  // read user specified mass into this->dblMass and dMassAdd in this->mass
   this->bodyMass = this->mass;
 
+
   if (dMassCheck(&this->bodyMass))
   {
     dMassRotate(&this->bodyMass, r);
Index: server/physics/Body.cc
===================================================================
--- server/physics/Body.cc	(revision 7016)
+++ server/physics/Body.cc	(working copy)
@@ -70,6 +70,7 @@
 
   this->rpyP = new ParamT<Quatern>("rpy", Quatern(), 0);
   this->rpyP->Callback( &Body::SetRotation, this );
+  this->turnGravityOffP = new ParamT<bool>("turnGravityOff", false, 0);
   Param::End();
 }
 
@@ -107,6 +108,7 @@
   this->nameP->Load(node);
   this->xyzP->Load(node);
   this->rpyP->Load(node);
+  this->turnGravityOffP->Load(node);
   Pose3d initPose;
 
   initPose.pos = **(this->xyzP);
@@ -134,8 +136,9 @@
   }
 
   // If no geoms are attached, then don't let gravity affect the body.
-  if (this->geoms.size()==0)
+  if (this->turnGravityOffP->GetValue() || this->geoms.size()==0)
   {
+    std::cout << "setting gravity to zero for: " << this->nameP->GetValue() << std::endl;
     this->SetGravityMode(false);
   }
 
Index: server/physics/HingeJoint.cc
===================================================================
--- server/physics/HingeJoint.cc	(revision 7016)
+++ server/physics/HingeJoint.cc	(working copy)
@@ -44,6 +44,7 @@
   this->axisP = new ParamT<Vector3>("axis",Vector3(0,1,0), 1);
   this->loStopP = new ParamT<Angle>("lowStop",-M_PI,0);
   this->hiStopP = new ParamT<Angle>("highStop",M_PI,0);
+  this->anchorOffsetP = new ParamT<Vector3>("anchorOffset",Vector3(0,0,0),0);
   Param::End();
 }
 
@@ -64,6 +65,7 @@
   this->axisP->Load(node);
   this->loStopP->Load(node);
   this->hiStopP->Load(node);
+  this->anchorOffsetP->Load(node);
 
   // Perform this three step ordering to ensure the parameters are set
   // properly. This is taken from the ODE wiki.
@@ -133,7 +135,7 @@
 // Set the anchor point
 void HingeJoint::SetAnchor( const Vector3 &anchor )
 {
-  dJointSetHingeAnchor( this->jointId, anchor.x, anchor.y, anchor.z );
+  dJointSetHingeAnchor( this->jointId, anchor.x+anchorOffsetP->GetValue().x, anchor.y+anchorOffsetP->GetValue().y, anchor.z+anchorOffsetP->GetValue().z );
 }
 
 
Index: server/physics/ode/ODEPhysics.hh
===================================================================
--- server/physics/ode/ODEPhysics.hh	(revision 7016)
+++ server/physics/ode/ODEPhysics.hh	(working copy)
@@ -133,6 +133,7 @@
 
   private: ParamT<double> *globalCFMP; 
   private: ParamT<double> *globalERPP; 
+  private: ParamT<bool> *quickStepP; 
 };
 
 /** \}*/
Index: server/physics/ode/ODEPhysics.cc
===================================================================
--- server/physics/ode/ODEPhysics.cc	(revision 7016)
+++ server/physics/ode/ODEPhysics.cc	(working copy)
@@ -70,6 +70,7 @@
   Param::Begin(&this->parameters);
   this->globalCFMP = new ParamT<double>("cfm", 10e-5, 0);
   this->globalERPP = new ParamT<double>("erp", 0.2, 0);
+  this->quickStepP = new ParamT<bool>("quickStep", false, 0);
   Param::End();
 }
 
@@ -88,6 +89,7 @@
 
   delete this->globalCFMP;
   delete this->globalERPP;
+  delete this->quickStepP;
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -103,6 +105,7 @@
   this->updateRateP->Load(cnode);
   this->globalCFMP->Load(cnode);
   this->globalERPP->Load(cnode);
+  this->quickStepP->Load(cnode);
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -115,6 +118,7 @@
   stream << prefix << "  " << *(this->updateRateP) << "\n";
   stream << prefix << "  " << *(this->globalCFMP) << "\n";
   stream << prefix << "  " << *(this->globalERPP) << "\n";
+  stream << prefix << "  " << *(this->quickStepP) << "\n";
   stream << prefix << "</physics:ode>\n";
 }
 
@@ -137,8 +141,10 @@
   dSpaceCollide( this->spaceId, this, CollisionCallback );
 
   // Update the dynamical model
-  dWorldStep( this->worldId, this->stepTimeP->GetValue() );
-  //dWorldQuickStep(this->worldId, this->stepTime);
+  if (this->quickStepP->GetValue())
+    dWorldQuickStep(this->worldId, this->stepTimeP->GetValue() );
+  else
+    dWorldStep( this->worldId, this->stepTimeP->GetValue() );
 
   // Very important to clear out the contact group
   dJointGroupEmpty( this->contactGroup );
@@ -266,15 +272,16 @@
         contact.surface.mode = dContactSlip1 | dContactSlip2 | 
                                dContactSoftERP | dContactSoftCFM |  
                                dContactBounce | dContactMu2 | dContactApprox1;
+        contact.surface.mode = 0;
 
 
         // Compute the CFM and ERP by assuming the two bodies form a
         // spring-damper system.
         h = self->stepTimeP->GetValue();
-        kp = 1 / (1 / geom1->contact->kp + 1 / geom2->contact->kp);
+        kp = 1.0 / (1.0 / geom1->contact->kp + 1.0 / geom2->contact->kp);
         kd = geom1->contact->kd + geom2->contact->kd;
         contact.surface.soft_erp = h * kp / (h * kp + kd);
-        contact.surface.soft_cfm = 1 / (h * kp + kd);
+        contact.surface.soft_cfm = 1.0 / (h * kp + kd);
 
         contact.surface.mu = MIN(geom1->contact->mu1, geom2->contact->mu1);
         contact.surface.mu2 = MIN(geom1->contact->mu2, geom2->contact->mu2);
Index: server/physics/TrimeshGeom.cc
===================================================================
--- server/physics/TrimeshGeom.cc	(revision 7016)
+++ server/physics/TrimeshGeom.cc	(working copy)
@@ -208,7 +208,13 @@
 
   this->geomId = dCreateTriMesh( this->spaceId, this->odeData,0,0,0 );
 
-  dMassSetTrimesh(&this->mass, this->massP->GetValue(), this->geomId);
+  if (this->customMassMatrix)
+    dMassSetParameters(&this->mass, this->massP->GetValue(),
+         this->cx, this->cy, this->cz,
+         this->ixx,this->iyy,this->izz,
+         this->ixy,this->ixz,this->iyz);
+  else
+    dMassSetTrimesh(&this->mass, this->massP->GetValue(), this->geomId);
 
   // Create the trimesh geometry
   this->SetGeom(this->geomId, true);
Index: server/sensors/Sensor.hh
===================================================================
--- server/sensors/Sensor.hh	(revision 7016)
+++ server/sensors/Sensor.hh	(working copy)
@@ -70,6 +70,7 @@
 
     /// \brief Set whether the sensor is active or not
     public: void SetActive(bool value);
+    public: bool IsActive();
 
     /// \brief  Load the child sensor
     protected: virtual void LoadChild(XMLConfigNode * /*node*/) {};
@@ -101,7 +102,6 @@
     protected: double lastUpdate;
     protected: std::string typeName;
   };
-  
   /// \}
 }
 #endif
Index: server/sensors/ray/RaySensor.cc
===================================================================
--- server/sensors/ray/RaySensor.cc	(revision 7016)
+++ server/sensors/ray/RaySensor.cc	(working copy)
@@ -273,7 +273,7 @@
 // Update the sensor information
 void RaySensor::UpdateChild()
 {
-//  if (this->active)
+  if (this->active)
   {
     std::vector<RayGeom*>::iterator iter;
     Pose3d poseDelta;
Index: server/sensors/Sensor.cc
===================================================================
--- server/sensors/Sensor.cc	(revision 7016)
+++ server/sensors/Sensor.cc	(working copy)
@@ -33,6 +33,7 @@
 #include "ControllerFactory.hh"
 #include "Simulator.hh"
 #include "Sensor.hh"
+#include "Simulator.hh"
 
 using namespace gazebo;
 
@@ -71,6 +72,14 @@
 
   this->LoadController( node->GetChildByNSPrefix("controller") );
   this->LoadChild(node);
+
+  double updateRate  = node->GetDouble("updateRate", 0, 0);
+  if (updateRate == 0)
+    this->updatePeriod = 0.0; // no throttling if updateRate is 0
+  else
+    this->updatePeriod = 1.0 / updateRate;
+  this->lastUpdate   = Simulator::Instance()->GetSimTime();
+
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -185,4 +194,11 @@
   this->active = value;
 }
 
+////////////////////////////////////////////////////////////////////////////////
+/// \brief Set whether the sensor is active or not
+bool Sensor::IsActive()
+{
+  return this->active;
+}
 
+
Index: server/Simulator.cc
===================================================================
--- server/Simulator.cc	(revision 7016)
+++ server/Simulator.cc	(working copy)
@@ -72,6 +72,7 @@
   timeout(-1),
   selectedEntity(NULL)
 {
+  selectedEntity = NULL;
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -291,6 +292,9 @@
   {
     currTime = this->GetRealTime();
 
+    //double tmpT1 = this->GetWallTime();
+    //fprintf(stderr, " before World::Instance()->Update() sim: %.5f t %.5f",this->simTime ,  tmpT1);
+
     if (physicsUpdateRate == 0 || 
         currTime - this->prevPhysicsTime >= physicsUpdatePeriod) 
     {
@@ -315,6 +319,9 @@
       World::Instance()->Update();
     }
 
+    //double tmpT2 = this->GetWallTime();
+    //fprintf(stderr, " world dt %.5f",tmpT2-tmpT1);
+
     // Update the rendering
     if (renderUpdateRate == 0 || 
         currTime - this->prevRenderTime >= renderUpdatePeriod)
Index: server/XMLConfig.cc
===================================================================
--- server/XMLConfig.cc	(revision 7016)
+++ server/XMLConfig.cc	(working copy)
@@ -513,29 +513,59 @@
 ///////////////////////////////////////////////////////////////////////////
 // Get a file name.  Always returns an absolute path.  If the filename
 // is entered as a relative path, we prepend the world file path.
+// std::string XMLConfigNode::GetFilename( const std::string &key, const std::string &def, int require) const
+// {
+//   std::string filename = this->GetString( key, def, require );
+//
+//   if (filename.empty())
+//     return "";
+//
+//   if (filename[0] == '/' || filename[0] == '~')
+//     return filename;
+//   else
+//   {
+//     std::string result;
+//
+//     if (this->config->filename[0] != '/' && this->config->filename[0] != '~')
+//       result = "/";
+//
+//     unsigned int last = this->config->filename.rfind("/");
+//     if (last==0 || last+1 != this->config->filename.size())
+//       result += this->config->filename + "/" + filename;
+//     else
+//       result += this->config->filename.substr(0,last) + "/" + filename;
+//
+//     return result;
+//   }
+// }
+///////////////////////////////////////////////////////////////////////////
+// Get a file name.  Always returns an absolute path.  If the filename
+// is entered as a relative path, we prepend the world file path.
+//
+// patch by stu to do relative path.  FIXME: what was the original implementation that's broken?
+// sglaser: Was completely broken.  Now returns a path relative to the
+// (original) working directory.
 std::string XMLConfigNode::GetFilename( const std::string &key, const std::string &def, int require) const
 {
   std::string filename = this->GetString( key, def, require );
 
-  if (filename.empty())
-    return "";
+  if (filename.empty() && require)
+  {
+    gzthrow("unable to find required filename attribute[" << key << "] in world file node["
+            << this->GetName() << "]");
+  }
+  else if (filename.empty())
+    return def;
 
-  if (filename[0] == '/' || filename[0] == '~')
+  if (filename[0] == '/')
     return filename;
   else
   {
-    std::string result;
-
-    if (this->config->filename[0] != '/' && this->config->filename[0] != '~')
-      result = "/";
-
-    unsigned int last = this->config->filename.rfind("/");
-    if (last==0 || last+1 != this->config->filename.size())
-      result += this->config->filename + "/" + filename;
+    int last_slash = this->config->filename.rfind("/");
+    if (last_slash < 0)
+      return filename;
     else
-      result += this->config->filename.substr(0,last) + "/" + filename;
-
-    return result;
+      return this->config->filename.substr(0,last_slash) + "/" + filename;
   }
 }
 
Index: server/GazeboConfig.cc
===================================================================
--- server/GazeboConfig.cc	(revision 7016)
+++ server/GazeboConfig.cc	(working copy)
@@ -67,31 +67,34 @@
     this->gazeboPaths.push_back(gazebo_resource_path);
   }
 
-  // if both paths are set, don't check the config file or use the defaults.
-  if(ogre_resource_path && gazebo_resource_path) 
-    return;
-
-
   if (cfgFile)
   {
     XMLConfig rc;
     XMLConfigNode *node;
     rc.Load(rcFilename);
 
-    node = rc.GetRootNode()->GetChild("gazeboPath");
-    while (node)
+    // if gazebo path is set, skip reading from .gazeborc
+    if(!gazebo_resource_path)
     {
-      gzmsg(1) << "Gazebo Path[" << node->GetValue() << "]\n";
-      this->gazeboPaths.push_back(node->GetValue());
-      node = node->GetNext("gazeboPath");
+      node = rc.GetRootNode()->GetChild("gazeboPath");
+      while (node)
+      {
+        gzmsg(1) << "Gazebo Path[" << node->GetValue() << "]\n";
+        this->gazeboPaths.push_back(node->GetValue());
+        node = node->GetNext("gazeboPath");
+      }
     }
 
-    node = rc.GetRootNode()->GetChild("ogrePath");
-    while (node)
+    // if ogre path is set, skip reading from .gazeborc
+    if(!ogre_resource_path)
     {
-      gzmsg(1) << "Ogre Path[" << node->GetValue() << "]\n";
-      this->ogrePaths.push_back( node->GetValue() );
-      node = node->GetNext("ogrePath");
+      node = rc.GetRootNode()->GetChild("ogrePath");
+      while (node)
+      {
+        gzmsg(1) << "Ogre Path[" << node->GetValue() << "]\n";
+        this->ogrePaths.push_back( node->GetValue() );
+        node = node->GetNext("ogrePath");
+      }
     }
     this->RTTMode = rc.GetRootNode()->GetString("RTTMode", "PBuffer");
 
@@ -99,9 +102,18 @@
   else
   {
     gzmsg(0) << "Unable to find the file ~/.gazeborc. Using default paths. This may cause OGRE to fail.\n";
-    this->gazeboPaths.push_back("/usr/local/share/gazebo");
-    this->ogrePaths.push_back("/usr/local/lib/OGRE");
-    this->ogrePaths.push_back("/usr/lib/OGRE");
+
+    if ( !gazebo_resource_path )
+    {
+	this->gazeboPaths.push_back("/usr/local/share/gazebo");
+    }
+
+    if ( !ogre_resource_path )
+    {
+	this->ogrePaths.push_back("/usr/local/lib/OGRE");
+	this->ogrePaths.push_back("/usr/lib/OGRE");
+    }
+
     this->RTTMode="PBuffer";
   }
 }
Index: server/gui/StatusBar.cc
===================================================================
--- server/gui/StatusBar.cc	(revision 7016)
+++ server/gui/StatusBar.cc	(working copy)
@@ -25,6 +25,7 @@
  */
 
 #include <stdio.h>
+#include <string.h>
 #include <FL/Fl_Value_Output.H>
 #include <FL/Fl_Output.H>
 #include <FL/Fl_Button.H>
Index: server/gui/GLWindow.cc
===================================================================
--- server/gui/GLWindow.cc	(revision 7016)
+++ server/gui/GLWindow.cc	(working copy)
@@ -227,21 +227,10 @@
     }
     else if (this->rightMousePressed)
     {
-      Model *model = dynamic_cast<Model*>(Simulator::Instance()->GetSelectedEntity());
-      if (model)
-      {
-        Pose3d pose = model->GetPose();
-        pose.pos.y -= d.x * 0.05;
-        pose.pos.x -= d.y * 0.05;
-        model->SetPose(pose);
-      }
-      else
-      {
-        Vector2<int> d = this->mousePos - this->prevMousePos;
-        this->directionVec.x = 0;
-        this->directionVec.y =  d.x * this->moveAmount;
-        this->directionVec.z =  d.y * this->moveAmount;
-      }
+      Vector2<int> d = this->mousePos - this->prevMousePos;
+      this->directionVec.x = 0;
+      this->directionVec.y =  d.x * this->moveAmount;
+      this->directionVec.z =  d.y * this->moveAmount;
     }
     else if (this->middleMousePressed)
     {
Index: server/World.hh
===================================================================
--- server/World.hh	(revision 7016)
+++ server/World.hh	(working copy)
@@ -92,6 +92,26 @@
   /// \return Pointer to the physics engine
   public: PhysicsEngine *GetPhysicsEngine() const;
 
+  /// Get the simulation time
+  /// \return The simulation time
+  public: double GetSimTime() const;
+
+  /// Get the pause time
+  /// \return The pause time
+  public: double GetPauseTime() const;
+
+  /// Get the start time
+  /// \return The start time
+  public: double GetStartTime() const;
+
+  /// Get the real time (elapsed time)
+  /// \return The real time
+  public: double GetRealTime() const;
+
+  /// \brief Get the wall clock time
+  /// \return The wall clock time
+  public: double GetWallTime() const;
+
   /// \brief Load all entities
   /// \param node XMLConfg node pointer
   /// \param parent Parent of the model to load
@@ -186,6 +206,9 @@
   /// Simulation interface
   private: SimulationIface *simIface;
 
+  /// Current simulation time
+  private: double simTime, pauseTime, startTime;
+
   private: friend class DestroyerT<World>;
   private: friend class SingletonT<World>;
 };
Index: server/controllers/Controller.hh
===================================================================
--- server/controllers/Controller.hh	(revision 7016)
+++ server/controllers/Controller.hh	(working copy)
@@ -105,6 +105,9 @@
   /// \brief The entity that owns this controller
   protected: Entity *parent;
 
+  /// \breif flag to keep controllers updating continuously
+  protected: ParamT<bool> *alwaysOnP;
+
   /// \brief Update period 
   protected: double updatePeriod;
   protected: ParamT<double> *updatePeriodP;
Index: server/controllers/camera/generic/Generic_Camera.cc
===================================================================
--- server/controllers/camera/generic/Generic_Camera.cc	(revision 7016)
+++ server/controllers/camera/generic/Generic_Camera.cc	(working copy)
@@ -86,7 +86,24 @@
 // Update the controller
 void Generic_Camera::UpdateChild()
 {
-  this->PutCameraData();
+
+  // do this first so there's chance for sensor to run 1 frame after activate
+  if (this->myParent->IsActive())
+    this->PutCameraData();
+
+  // activate if iface open
+  if (this->cameraIface->Lock(1))
+  {
+    if (this->cameraIface->GetOpenCount() > 0)
+      this->myParent->SetActive(true);
+    else
+      this->myParent->SetActive(false);
+
+    //std::cout << " camera open count " << this->cameraIface->GetOpenCount() << std::endl;
+    this->cameraIface->Unlock();
+  }
+  //std::cout << " camera     active " << this->myParent->IsActive() << std::endl;
+
 }
 
 ////////////////////////////////////////////////////////////////////////////////
Index: server/controllers/Controller.cc
===================================================================
--- server/controllers/Controller.cc	(revision 7016)
+++ server/controllers/Controller.cc	(working copy)
@@ -43,6 +43,7 @@
 {
   Param::Begin(&this->parameters);
   this->nameP = new ParamT<std::string>("name","",1);
+  this->alwaysOnP = new ParamT<bool>("alwaysOn", false, 0);
   this->updatePeriodP = new ParamT<double>("updateRate", 10, 0);
   Param::End();
 
@@ -60,6 +61,7 @@
 {
   this->Fini();
   delete this->nameP;
+  delete this->alwaysOnP;
   delete this->updatePeriodP;
 }
 
@@ -75,10 +77,17 @@
   this->typeName = node->GetName();
 
   this->nameP->Load(node);
+
+  this->alwaysOnP->Load(node);
+
   this->updatePeriodP->Load(node);
-  this->updatePeriod = 1.0 / (this->updatePeriodP->GetValue() + 1e-6);
 
-  this->lastUpdate = -1e6;
+  double updateRate  = this->updatePeriodP->GetValue();
+  if (updateRate == 0)
+    this->updatePeriod = 0.0; // no throttling if updateRate is 0
+  else
+    this->updatePeriod = 1.0 / updateRate;
+  this->lastUpdate   = Simulator::Instance()->GetSimTime();
 
   childNode = node->GetChildByNSPrefix("interface");
 
@@ -178,7 +187,7 @@
 /// Update the controller. Called every cycle.
 void Controller::Update()
 {
-  if (this->IsConnected())
+  if (this->IsConnected() || this->alwaysOnP->GetValue())
   {
     if (lastUpdate + updatePeriod <= Simulator::Instance()->GetSimTime())
     {
Index: server/controllers/ptz/generic/Generic_PTZ.cc
===================================================================
--- server/controllers/ptz/generic/Generic_PTZ.cc	(revision 7016)
+++ server/controllers/ptz/generic/Generic_PTZ.cc	(working copy)
@@ -70,10 +70,10 @@
 // Destructor
 Generic_PTZ::~Generic_PTZ()
 {
-  if (this->panJoint)
-    delete this->panJoint;
-  if (this->tiltJoint)
-    delete this->tiltJoint;
+  //if (this->panJoint)
+  //  delete this->panJoint;
+  //if (this->tiltJoint)
+  //  delete this->tiltJoint;
 
   this->panJoint = NULL;
   this->tiltJoint = NULL;
Index: server/World.cc
===================================================================
--- server/World.cc	(revision 7016)
+++ server/World.cc	(working copy)
@@ -27,6 +27,7 @@
 #include <assert.h>
 #include <sstream>
 #include <fstream>
+#include <sys/time.h> //gettimeofday
 
 #include "Global.hh"
 #include "GazeboError.hh"
@@ -57,6 +58,9 @@
   this->server = NULL;
   this->simIface = NULL;
 
+  this->simTime = 0.0;
+  this->pauseTime = 0.0;
+  this->startTime = 0.0;
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -172,6 +176,7 @@
 
   this->physicsEngine->Init();
 
+  this->startTime = this->GetWallTime();
   this->toAddModels.clear();
   this->toDeleteModels.clear();
 
@@ -185,6 +190,11 @@
   std::vector< Model* >::iterator miter;
   std::vector< Model* >::iterator miter2;
 
+  this->simTime += this->physicsEngine->GetStepTime();
+
+  //double tmpT1 = this->GetWallTime();
+  //fprintf(stderr, " | sim ");
+
   // Update all the models
   for (miter=this->models.begin(); miter!=this->models.end(); miter++)
   {
@@ -194,14 +204,27 @@
     }
   }
 
+  //double tmpT2 = this->GetWallTime();
+  //fprintf(stderr, " model dt: %.5f",tmpT2-tmpT1);
+
   if (!Simulator::Instance()->IsPaused() &&
        Simulator::Instance()->GetPhysicsEnabled())
   {
     this->physicsEngine->Update();
   }
+  else
+  {
+    this->pauseTime += this->physicsEngine->GetStepTime();
+  }
 
+  //double tmpT3 = this->GetWallTime();
+  //fprintf(stderr, " physics dt: %.5f",tmpT3-tmpT2);
+
   this->UpdateSimulationIface();
 
+  //double tmpT4 = this->GetWallTime();
+  //fprintf(stderr, " Iface dt: %.5f",tmpT4-tmpT3);
+
   // Copy the newly created models into the main model vector
   std::copy(this->toAddModels.begin(), this->toAddModels.end(),
             std::back_inserter(this->models));
@@ -219,6 +242,9 @@
 
   this->toDeleteModels.clear();
 
+  //double tmpT5 = this->GetWallTime();
+  //fprintf(stderr, " add/del models dt: %.5f | ",tmpT5-tmpT4);
+
   return 0;
 }
 
@@ -273,6 +299,41 @@
   return this->physicsEngine;
 }
 
+////////////////////////////////////////////////////////////////////////////////
+// Get the simulation time
+double World::GetSimTime() const
+{
+  return this->simTime;
+}
+////////////////////////////////////////////////////////////////////////////////
+// Get the pause time
+double World::GetPauseTime() const
+{
+  return this->pauseTime;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+/// Get the start time
+double World::GetStartTime() const
+{
+  return this->startTime;
+}
+////////////////////////////////////////////////////////////////////////////////
+/// Get the real time (elapsed time)
+double World::GetRealTime() const
+{
+  return this->GetWallTime() - this->startTime;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+/// Get the wall clock time
+double World::GetWallTime() const
+{
+  struct timeval tv;
+  gettimeofday(&tv, NULL);
+  return tv.tv_sec + tv.tv_usec * 1e-6;
+}
+
 ///////////////////////////////////////////////////////////////////////////////
 // Load a model
 int World::LoadEntities(XMLConfigNode *node, Model *parent)
Index: SConstruct
===================================================================
--- SConstruct	(revision 7016)
+++ SConstruct	(working copy)
@@ -22,8 +22,9 @@
 # 3rd party packages
 #
 parseConfigs=['pkg-config --cflags --libs OGRE',
+              'pkg-config --cflags --libs freeimage', 
+              'ode-config --cflags --libs', 
               'xml2-config --cflags --libs', 
-      	      'ode-config --cflags --libs',
               'fltk-config --cflags --libs --ldflags --use-gl --use-images',
               'pkg-config --cflags --libs xft'
               ]
@@ -81,7 +82,7 @@
 rcconfig = env.RCConfig(target='gazeborc', source=Value(install_prefix))
 
 # DEFAULT list of subdirectories to build
-subdirs = ['libgazebo','server', 'player']
+subdirs = ['libgazebo','server']
 
 # Set the compile mode
 if env['mode'] == 'debug':
