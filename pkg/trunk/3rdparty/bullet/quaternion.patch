Index: src/LinearMath/btQuaternion.h
===================================================================
--- src/LinearMath/btQuaternion.h	(revision 1422)
+++ src/LinearMath/btQuaternion.h	(working copy)
@@ -198,7 +198,12 @@
 	{
 		btScalar s = btSqrt(length2() * q.length2());
 		assert(s != btScalar(0.0));
-		return btAcos(dot(q) / s);
+                btScalar retval;
+                if (dot(q) < 0) // Take care of long angle case see http://en.wikipedia.org/wiki/Slerp
+                  retval = btAcos(GEN_clamped(dot(-q) / s, -1.0, 1.0)); //Added min to prevent nan result when floating point errors made dot > 1
+                else 
+                  retval = btAcos(GEN_clamped(dot(q) / s, -1.0, 1.0)); //Added min to prevent nan result when floating point errors made dot > 1
+		return retval;
 	}
   /**@brief Return the angle of rotation represented by this quaternion */
 	btScalar getAngle() const 
Index: src/LinearMath/btMatrix3x3.h
===================================================================
--- src/LinearMath/btMatrix3x3.h	(revision 1422)
+++ src/LinearMath/btMatrix3x3.h	(working copy)
@@ -274,6 +274,74 @@
 		};
 
 
+  /**@brief Get the matrix represented as euler angles around ZYX
+   * @param yaw Yaw around X axis
+   * @param pitch Pitch around Y axis
+   * @param roll around X axis 
+   * @param solution_number Which solution of two possible solutions ( 1 or 2) are possible values*/	
+  void getEulerZYX(btScalar& yaw, btScalar& pitch, btScalar& roll, unsigned int solution_number = 1) const
+  {
+    struct Euler{btScalar yaw, pitch, roll;};
+    Euler euler_out;
+    Euler euler_out2; //second solution
+    //get the pointer to the raw data
+    
+    // Check that pitch is not at a singularity
+    if (btFabs(m_el[2].x()) >= 1)
+    {
+      euler_out.yaw = 0;
+      euler_out2.yaw = 0;
+	
+      // From difference of angles formula
+      double delta = btAtan2(m_el[0].x(),m_el[0].z());
+      if (m_el[2].x() > 0)  //gimbal locked up
+      {
+        euler_out.pitch = M_PI / 2.0;
+        euler_out2.pitch = M_PI / 2.0;
+        euler_out.roll = euler_out.pitch + delta;
+        euler_out2.roll = euler_out.pitch + delta;
+      }
+      else // gimbal locked down
+      {
+        euler_out.pitch = -M_PI / 2.0;
+        euler_out2.pitch = -M_PI / 2.0;
+        euler_out.roll = -euler_out.pitch + delta;
+        euler_out2.roll = -euler_out.pitch + delta;
+      }
+    }
+    else
+    {
+      euler_out.pitch = - btAsin(m_el[2].x());
+      euler_out2.pitch = M_PI - euler_out.pitch;
+	
+      euler_out.roll = btAtan2(m_el[2].y()/cos(euler_out.pitch), 
+			       m_el[2].z()/cos(euler_out.pitch));
+      euler_out2.roll = btAtan2(m_el[2].y()/cos(euler_out2.pitch), 
+				m_el[2].z()/cos(euler_out2.pitch));
+	
+      euler_out.yaw = btAtan2(m_el[1].x()/cos(euler_out.pitch), 
+			      m_el[0].x()/cos(euler_out.pitch));
+      euler_out2.yaw = btAtan2(m_el[1].x()/cos(euler_out2.pitch), 
+                               m_el[0].x()/cos(euler_out2.pitch));
+    }
+    
+    if (solution_number == 1)
+    { yaw = euler_out.yaw; 
+    pitch = euler_out.pitch;
+    roll = euler_out.roll;
+    }
+    else
+    { yaw = euler_out2.yaw; 
+    pitch = euler_out2.pitch;
+    roll = euler_out2.roll;
+    }
+
+	
+
+    return;
+
+  }
+
   /**@brief Create a scaled copy of the matrix 
    * @param s Scaling vector The elements of the vector will scale each column */
 		
