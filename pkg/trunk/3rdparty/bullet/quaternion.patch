Index: src/LinearMath/btTransform.h
===================================================================
--- src/LinearMath/btTransform.h	(revision 1343)
+++ src/LinearMath/btTransform.h	(working copy)
@@ -21,34 +21,39 @@
 #include "btMatrix3x3.h"
 
 
-///The btTransform class supports rigid transforms with only translation and rotation and no scaling/shear.
-///It can be used in combination with btVector3, btQuaternion and btMatrix3x3 linear algebra classes.
+/**@brief The btTransform class supports rigid transforms with only translation and rotation and no scaling/shear.
+ *It can be used in combination with btVector3, btQuaternion and btMatrix3x3 linear algebra classes. */
 class btTransform {
 	
 
 public:
 	
-	
+  /**@brief No initialization constructor */
 	btTransform() {}
-
+  /**@brief Constructor from btQuaternion (optional btVector3 )
+   * @param q Rotation from quaternion 
+   * @param c Translation from Vector (default 0,0,0) */
 	explicit SIMD_FORCE_INLINE btTransform(const btQuaternion& q, 
 		const btVector3& c = btVector3(btScalar(0), btScalar(0), btScalar(0))) 
 		: m_basis(q),
 		m_origin(c)
 	{}
 
+  /**@brief Constructor from btMatrix3x3 (optional btVector3)
+   * @param b Rotation from Matrix 
+   * @param c Translation from Vector default (0,0,0)*/
 	explicit SIMD_FORCE_INLINE btTransform(const btMatrix3x3& b, 
 		const btVector3& c = btVector3(btScalar(0), btScalar(0), btScalar(0)))
 		: m_basis(b),
 		m_origin(c)
 	{}
-
+  /**@brief Copy constructor */
 	SIMD_FORCE_INLINE btTransform (const btTransform& other)
 		: m_basis(other.m_basis),
 		m_origin(other.m_origin)
 	{
 	}
-
+  /**@brief Assignment Operator */
 	SIMD_FORCE_INLINE btTransform& operator=(const btTransform& other)
 	{
 		m_basis = other.m_basis;
@@ -57,6 +62,10 @@
 	}
 
 
+  /**@brief Set the current transform as the value of the product of two transforms
+   * @param t1 Transform 1
+   * @param t2 Transform 2
+   * This = Transform1 * Transform2 */
 		SIMD_FORCE_INLINE void mult(const btTransform& t1, const btTransform& t2) {
 			m_basis = t1.m_basis * t2.m_basis;
 			m_origin = t1(t2.m_origin);
@@ -69,7 +78,7 @@
 		}
 		*/
 
-
+/**@brief Return the transform of the vector */
 	SIMD_FORCE_INLINE btVector3 operator()(const btVector3& x) const
 	{
 		return btVector3(m_basis[0].dot(x) + m_origin.x(), 
@@ -77,17 +86,29 @@
 			m_basis[2].dot(x) + m_origin.z());
 	}
 
+  /**@brief Return the transform of the vector */
 	SIMD_FORCE_INLINE btVector3 operator*(const btVector3& x) const
 	{
 		return (*this)(x);
 	}
 
+  /**@brief Return the transform of the btQuaternion */
+	SIMD_FORCE_INLINE btQuaternion operator*(const btQuaternion& q) const
+	{
+		return getRotation() * q;
+	}
+
+  /**@brief Return the basis matrix for the rotation */
 	SIMD_FORCE_INLINE btMatrix3x3&       getBasis()          { return m_basis; }
+  /**@brief Return the basis matrix for the rotation */
 	SIMD_FORCE_INLINE const btMatrix3x3& getBasis()    const { return m_basis; }
 
+  /**@brief Return the origin vector translation */
 	SIMD_FORCE_INLINE btVector3&         getOrigin()         { return m_origin; }
+  /**@brief Return the origin vector translation */
 	SIMD_FORCE_INLINE const btVector3&   getOrigin()   const { return m_origin; }
 
+  /**@brief Return a quaternion representing the rotation */
 	btQuaternion getRotation() const { 
 		btQuaternion q;
 		m_basis.getRotation(q);
@@ -95,12 +116,16 @@
 	}
 	
 	
+  /**@brief Set from an array 
+   * @param m A pointer to a 15 element array (12 rotation(row major padded on the right by 1), and 3 translation */
 	void setFromOpenGLMatrix(const btScalar *m)
 	{
 		m_basis.setFromOpenGLSubMatrix(m);
 		m_origin.setValue(m[12],m[13],m[14]);
 	}
 
+  /**@brief Fill an array representation
+   * @param m A pointer to a 15 element array (12 rotation(row major padded on the right by 1), and 3 translation */
 	void getOpenGLMatrix(btScalar *m) const 
 	{
 		m_basis.getOpenGLSubMatrix(m);
@@ -110,6 +135,8 @@
 		m[15] = btScalar(1.0);
 	}
 
+  /**@brief Set the translational element
+   * @param origin The vector to set the translation to */
 	SIMD_FORCE_INLINE void setOrigin(const btVector3& origin) 
 	{ 
 		m_origin = origin;
@@ -118,26 +145,29 @@
 	SIMD_FORCE_INLINE btVector3 invXform(const btVector3& inVec) const;
 
 
-
+  /**@brief Set the rotational element by btMatrix3x3 */
 	SIMD_FORCE_INLINE void setBasis(const btMatrix3x3& basis)
 	{ 
 		m_basis = basis;
 	}
 
+  /**@brief Set the rotational element by btQuaternion */
 	SIMD_FORCE_INLINE void setRotation(const btQuaternion& q)
 	{
 		m_basis.setRotation(q);
 	}
 
 
-
+  /**@brief Set this transformation to the identity */
 	void setIdentity()
 	{
 		m_basis.setIdentity();
 		m_origin.setValue(btScalar(0.0), btScalar(0.0), btScalar(0.0));
 	}
 
-	
+  /**@brief Multiply this Transform by another 
+   * @param t The other transform 
+   * @todo check order */
 	btTransform& operator*=(const btTransform& t) 
 	{
 		m_origin += m_basis * t.m_origin;
@@ -145,16 +175,22 @@
 		return *this;
 	}
 
+  /**@brief Return the inverse of this transform */
 	btTransform inverse() const
 	{ 
 		btMatrix3x3 inv = m_basis.transpose();
 		return btTransform(inv, inv * -m_origin);
 	}
 
+  /**@brief Return the inverse of this transform times the other 
+   * @param The other transform 
+   * @todo check which is inverted*/
 	btTransform inverseTimes(const btTransform& t) const;  
 
+  /**@brief Return the product of this transform and the other */
 	btTransform operator*(const btTransform& t) const;
 
+  /**@brief Return an identity transform */
 	static btTransform	getIdentity()
 	{
 		btTransform tr;
@@ -163,8 +199,9 @@
 	}
 	
 private:
-
+  ///Storage for the rotation
 	btMatrix3x3 m_basis;
+  ///Storage for the translation
 	btVector3   m_origin;
 };
 
@@ -191,6 +228,7 @@
 		(*this)(t.m_origin));
 }
 
+/**@brief Test if two transforms have all elements equal */
 SIMD_FORCE_INLINE bool operator==(const btTransform& t1, const btTransform& t2)
 {
    return ( t1.getBasis()  == t2.getBasis() &&
Index: src/LinearMath/btQuaternion.h
===================================================================
--- src/LinearMath/btQuaternion.h	(revision 1343)
+++ src/LinearMath/btQuaternion.h	(working copy)
@@ -17,30 +17,43 @@
 #ifndef SIMD__QUATERNION_H_
 #define SIMD__QUATERNION_H_
 
+#include <algorithm>
 #include "btVector3.h"
 
-///The btQuaternion implements quaternion to perform linear algebra rotations in combination with btMatrix3x3, btVector3 and btTransform.
+/**@brief The btQuaternion implements quaternion to perform linear algebra rotations in combination with btMatrix3x3, btVector3 and btTransform. */
 class btQuaternion : public btQuadWord {
 public:
+  /**@brief No initialization constructor */
 	btQuaternion() {}
 
 	//		template <typename btScalar>
 	//		explicit Quaternion(const btScalar *v) : Tuple4<btScalar>(v) {}
-
+  /**@brief Constructor from scalars */
 	btQuaternion(const btScalar& x, const btScalar& y, const btScalar& z, const btScalar& w) 
 		: btQuadWord(x, y, z, w) 
 	{}
-
+  /**@brief Axis angle Constructor
+   * @param axis The axis which the rotation is around
+   * @param angle The magnitude of the rotation around the angle (Radians) */
 	btQuaternion(const btVector3& axis, const btScalar& angle) 
 	{ 
 		setRotation(axis, angle); 
 	}
-
+  /**@brief Constructor from Euler angles
+   * @param yaw Angle around Y unless BT_EULER_DEFAULT_ZYX defined then Z
+   * @param pitch Angle around X unless BT_EULER_DEFAULT_ZYX defined then Y
+   * @param roll Angle around Z unless BT_EULER_DEFAULT_ZYX defined then X */
 	btQuaternion(const btScalar& yaw, const btScalar& pitch, const btScalar& roll)
 	{ 
+#ifndef BT_EULER_DEFAULT_ZYX
 		setEuler(yaw, pitch, roll); 
+#else
+		setEulerZYX(yaw, pitch, roll); 
+#endif 
 	}
-
+  /**@brief Set the rotation using axis angle notation 
+   * @param axis The axis around which to rotate
+   * @param angle The magnitude of the rotation in Radians */
 	void setRotation(const btVector3& axis, const btScalar& angle)
 	{
 		btScalar d = axis.length();
@@ -49,7 +62,10 @@
 		setValue(axis.x() * s, axis.y() * s, axis.z() * s, 
 			btCos(angle * btScalar(0.5)));
 	}
-
+  /**@brief Set the quaternion using Euler angles
+   * @param yaw Angle around Y
+   * @param pitch Angle around X
+   * @param roll Angle around Z */
 	void setEuler(const btScalar& yaw, const btScalar& pitch, const btScalar& roll)
 	{
 		btScalar halfYaw = btScalar(yaw) * btScalar(0.5);  
@@ -66,26 +82,52 @@
 			sinRoll * cosPitch * cosYaw - cosRoll * sinPitch * sinYaw,
 			cosRoll * cosPitch * cosYaw + sinRoll * sinPitch * sinYaw);
 	}
-
+  /**@brief Set the quaternion using euler angles 
+   * @param yaw Angle around Z
+   * @param pitch Angle around Y
+   * @param roll Angle around X */
+	void setEulerZYX(const btScalar& yaw, const btScalar& pitch, const btScalar& roll)
+	{
+		btScalar halfYaw = btScalar(yaw) * btScalar(0.5);  
+		btScalar halfPitch = btScalar(pitch) * btScalar(0.5);  
+		btScalar halfRoll = btScalar(roll) * btScalar(0.5);  
+		btScalar cosYaw = btCos(halfYaw);
+		btScalar sinYaw = btSin(halfYaw);
+		btScalar cosPitch = btCos(halfPitch);
+		btScalar sinPitch = btSin(halfPitch);
+		btScalar cosRoll = btCos(halfRoll);
+		btScalar sinRoll = btSin(halfRoll);
+		setValue(sinRoll * cosPitch * cosYaw - cosRoll * sinPitch * sinYaw, //x
+                         cosRoll * sinPitch * cosYaw + sinRoll * cosPitch * sinYaw, //y
+                         cosRoll * cosPitch * sinYaw - sinRoll * sinPitch * cosYaw, //z
+                         cosRoll * cosPitch * cosYaw + sinRoll * sinPitch * sinYaw); //formerly yzx
+	}
+  /**@brief Add two quaternions
+   * @param q The quaternion to add to this one */
 	btQuaternion& operator+=(const btQuaternion& q)
 	{
 		m_x += q.x(); m_y += q.y(); m_z += q.z(); m_unusedW += q.m_unusedW;
 		return *this;
 	}
-
+  /**@brief Subtract out a quaternion
+   * @param q The quaternion to subtract from this one */
 	btQuaternion& operator-=(const btQuaternion& q) 
 	{
 		m_x -= q.x(); m_y -= q.y(); m_z -= q.z(); m_unusedW -= q.m_unusedW;
 		return *this;
 	}
 
+  /**@brief Scale this quaternion
+   * @param s The scalar to scale by */
 	btQuaternion& operator*=(const btScalar& s)
 	{
 		m_x *= s; m_y *= s; m_z *= s; m_unusedW *= s;
 		return *this;
 	}
 
-
+  /**@brief Multiply this quaternion by q on the right
+   * @param q The other quaternion 
+   * Equivilant to this = this * q */
 	btQuaternion& operator*=(const btQuaternion& q)
 	{
 		setValue(m_unusedW * q.x() + m_x * q.m_unusedW + m_y * q.z() - m_z * q.y(),
@@ -94,27 +136,34 @@
 			m_unusedW * q.m_unusedW - m_x * q.x() - m_y * q.y() - m_z * q.z());
 		return *this;
 	}
-
+  /**@brief Return the dot product between this quaternion and another
+   * @param q The other quaternion */
 	btScalar dot(const btQuaternion& q) const
 	{
 		return m_x * q.x() + m_y * q.y() + m_z * q.z() + m_unusedW * q.m_unusedW;
 	}
 
+  /**@brief Return the length squared of the quaternion */
 	btScalar length2() const
 	{
 		return dot(*this);
 	}
 
+  /**@brief Return the length of the quaternion */
 	btScalar length() const
 	{
 		return btSqrt(length2());
 	}
 
+  /**@brief Normalize the quaternion 
+   * Such that x^2 + y^2 + z^2 +w^2 = 1 */
 	btQuaternion& normalize() 
 	{
 		return *this /= length();
 	}
 
+  /**@brief Return a scaled version of this quaternion
+   * @param s The scale factor */
 	SIMD_FORCE_INLINE btQuaternion
 	operator*(const btScalar& s) const
 	{
@@ -122,33 +171,36 @@
 	}
 
 
-
+  /**@brief Return an inversely scaled versionof this quaternion
+   * @param s The inverse scale factor */
 	btQuaternion operator/(const btScalar& s) const
 	{
 		assert(s != btScalar(0.0));
 		return *this * (btScalar(1.0) / s);
 	}
 
-
+  /**@brief Inversely scale this quaternion
+   * @param s The scale factor */
 	btQuaternion& operator/=(const btScalar& s) 
 	{
 		assert(s != btScalar(0.0));
 		return *this *= btScalar(1.0) / s;
 	}
 
-
+  /**@brief Return a normalized version of this quaternion */
 	btQuaternion normalized() const 
 	{
 		return *this / length();
 	} 
-
+  /**@brief Return the angle between this quaternion and the other 
+   * @param q The other quaternion */
 	btScalar angle(const btQuaternion& q) const 
 	{
 		btScalar s = btSqrt(length2() * q.length2());
 		assert(s != btScalar(0.0));
-		return btAcos(dot(q) / s);
+		return btAcos(std::min(dot(q), (btScalar)1.0) / s); //Added min to prevent nan result when floating point errors made dot > 1
 	}
-
+  /**@brief Return the angle of rotation represented by this quaternion */
 	btScalar getAngle() const 
 	{
 		btScalar s = btScalar(2.) * btAcos(m_unusedW);
@@ -156,12 +208,14 @@
 	}
 
 
-
+  /**@brief Return the inverse of this quaternion */
 	btQuaternion inverse() const
 	{
 		return btQuaternion(-m_x, -m_y, -m_z, m_unusedW);
 	}
 
+  /**@brief Return the sum of this quaternion and the other 
+   * @param q2 The other quaternion */
 	SIMD_FORCE_INLINE btQuaternion
 	operator+(const btQuaternion& q2) const
 	{
@@ -169,6 +223,8 @@
 		return btQuaternion(q1.x() + q2.x(), q1.y() + q2.y(), q1.z() + q2.z(), q1.m_unusedW + q2.m_unusedW);
 	}
 
+  /**@brief Return the difference between this quaternion and the other 
+   * @param q2 The other quaternion */
 	SIMD_FORCE_INLINE btQuaternion
 	operator-(const btQuaternion& q2) const
 	{
@@ -176,12 +232,14 @@
 		return btQuaternion(q1.x() - q2.x(), q1.y() - q2.y(), q1.z() - q2.z(), q1.m_unusedW - q2.m_unusedW);
 	}
 
+  /**@brief Return the negative of this quaternion 
+   * This simply negates each element */
 	SIMD_FORCE_INLINE btQuaternion operator-() const
 	{
 		const btQuaternion& q2 = *this;
 		return btQuaternion( - q2.x(), - q2.y(),  - q2.z(),  - q2.m_unusedW);
 	}
-
+  /**@todo document this and it's use */
 	SIMD_FORCE_INLINE btQuaternion farthest( const btQuaternion& qd) const 
 	{
 		btQuaternion diff,sum;
@@ -192,6 +250,10 @@
 		return (-qd);
 	}
 
+  /**@brief Return the quaternion which is the result of Spherical Linear Interpolation between this and the other quaternion
+   * @param q The other quaternion to interpolate with 
+   * @param t The ratio between this and q to interpolate.  If t = 0 the result is this, if t=1 the result is q.
+   * Slerp interpolates assuming constant velocity.  */
 	btQuaternion slerp(const btQuaternion& q, const btScalar& t) const
 	{
 		btScalar theta = angle(q);
@@ -217,7 +279,7 @@
 };
 
 
-
+/**@brief Return the negative of a quaternion */
 SIMD_FORCE_INLINE btQuaternion
 operator-(const btQuaternion& q)
 {
@@ -226,7 +288,7 @@
 
 
 
-
+/**@brief Return the product of two quaternions */
 SIMD_FORCE_INLINE btQuaternion
 operator*(const btQuaternion& q1, const btQuaternion& q2) {
 	return btQuaternion(q1.w() * q2.x() + q1.x() * q2.w() + q1.y() * q2.z() - q1.z() * q2.y(),
@@ -253,6 +315,7 @@
 		-w.x() * q.x() - w.y() * q.y() - w.z() * q.z()); 
 }
 
+/**@brief Calculate the dot product between two quaternions */
 SIMD_FORCE_INLINE btScalar 
 dot(const btQuaternion& q1, const btQuaternion& q2) 
 { 
@@ -260,25 +323,32 @@
 }
 
 
+/**@brief Return the length of a quaternion */
 SIMD_FORCE_INLINE btScalar
 length(const btQuaternion& q) 
 { 
 	return q.length(); 
 }
 
+/**@brief Return the angle between two quaternions*/
 SIMD_FORCE_INLINE btScalar
 angle(const btQuaternion& q1, const btQuaternion& q2) 
 { 
 	return q1.angle(q2); 
 }
 
-
+/**@brief Return the inverse of a quaternion*/
 SIMD_FORCE_INLINE btQuaternion
 inverse(const btQuaternion& q) 
 {
 	return q.inverse();
 }
 
+/**@brief Return the result of spherical linear interpolation betwen two quaternions 
+ * @param q1 The first quaternion
+ * @param q2 The second quaternion 
+ * @param t The ration between q1 and q2.  t = 0 return q1, t=1 returns q2 
+ * Slerp assumes constant velocity between positions. */
 SIMD_FORCE_INLINE btQuaternion
 slerp(const btQuaternion& q1, const btQuaternion& q2, const btScalar& t) 
 {
Index: src/LinearMath/btVector3.h
===================================================================
--- src/LinearMath/btVector3.h	(revision 1343)
+++ src/LinearMath/btVector3.h	(working copy)
@@ -19,20 +19,28 @@
 
 #include "btQuadWord.h"
 
-///btVector3 can be used to represent 3D points and vectors.
-///It has an un-used w component to suit 16-byte alignment when btVector3 is stored in containers. This extra component can be used by derived classes (Quaternion?) or by user
-///Ideally, this class should be replaced by a platform optimized SIMD version that keeps the data in registers
+/**@brief btVector3 can be used to represent 3D points and vectors.
+ * It has an un-used w component to suit 16-byte alignment when btVector3 is stored in containers. This extra component can be used by derived classes (Quaternion?) or by user
+ *deally, this class should be replaced by a platform optimized SIMD version that keeps the data in registers
+ */
 class	btVector3 : public btQuadWord {
 
 public:
+  /**@brief No initialization constructor */
 	SIMD_FORCE_INLINE btVector3() {}
 
+  /**@brief Constructor from btQuadWordStorage (btVector3 inherits from this so is also valid)
+   * Note: Vector3 derives from btQuadWordStorage*/
 	SIMD_FORCE_INLINE btVector3(const btQuadWordStorage& q) 
 		: btQuadWord(q)
 	{
 	}
 	
-
+  /**@brief Constructor from scalars 
+   * @param x X value
+   * @param y Y value 
+   * @param z Z value 
+   */
 	SIMD_FORCE_INLINE btVector3(const btScalar& x, const btScalar& y, const btScalar& z) 
 		:btQuadWord(x,y,z,btScalar(0.))
 	{
@@ -44,7 +52,8 @@
 //	}
 
 	
-
+/**@brief Add a vector to this one 
+ * @param The vector to add to this one */
 	SIMD_FORCE_INLINE btVector3& operator+=(const btVector3& v)
 	{
 
@@ -53,60 +62,80 @@
 	}
 
 
-
+  /**@brief Subtract a vector from this one
+   * @param The vector to subtract */
 	SIMD_FORCE_INLINE btVector3& operator-=(const btVector3& v) 
 	{
 		m_x -= v.x(); m_y -= v.y(); m_z -= v.z();
 		return *this;
 	}
-
+  /**@brief Scale the vector
+   * @param s Scale factor */
 	SIMD_FORCE_INLINE btVector3& operator*=(const btScalar& s)
 	{
 		m_x *= s; m_y *= s; m_z *= s;
 		return *this;
 	}
 
+  /**@brief Inversely scale the vector 
+   * @param s Scale factor to divide by */
 	SIMD_FORCE_INLINE btVector3& operator/=(const btScalar& s) 
 	{
 		btFullAssert(s != btScalar(0.0));
 		return *this *= btScalar(1.0) / s;
 	}
 
+  /**@brief Return the dot product
+   * @param v The other vector in the dot product */
 	SIMD_FORCE_INLINE btScalar dot(const btVector3& v) const
 	{
 		return m_x * v.x() + m_y * v.y() + m_z * v.z();
 	}
 
+  /**@brief Return the length of the vector squared */
 	SIMD_FORCE_INLINE btScalar length2() const
 	{
 		return dot(*this);
 	}
 
+  /**@brief Return the length of the vector */
 	SIMD_FORCE_INLINE btScalar length() const
 	{
 		return btSqrt(length2());
 	}
 
+  /**@brief Return the distance squared between the ends of this and another vector
+   * This is symantically treating the vector like a point */
 	SIMD_FORCE_INLINE btScalar distance2(const btVector3& v) const;
 
+  /**@brief Return the distance between the ends of this and another vector
+   * This is symantically treating the vector like a point */
 	SIMD_FORCE_INLINE btScalar distance(const btVector3& v) const;
 
+  /**@brief Normalize this vector 
+   * x^2 + y^2 + z^2 = 1 */
 	SIMD_FORCE_INLINE btVector3& normalize() 
 	{
 		return *this /= length();
 	}
 
+  /**@brief Return a normalized version of this vector */
 	SIMD_FORCE_INLINE btVector3 normalized() const;
 
+  /**@brief Rotate this vector 
+   * @param wAxis The axis to rotate about 
+   * @param angle The angle to rotate by */
 	SIMD_FORCE_INLINE btVector3 rotate( const btVector3& wAxis, const btScalar angle );
 
+  /**@brief Return the angle between this and another vector
+   * @param v The other vector */
 	SIMD_FORCE_INLINE btScalar angle(const btVector3& v) const 
 	{
 		btScalar s = btSqrt(length2() * v.length2());
 		btFullAssert(s != btScalar(0.0));
 		return btAcos(dot(v) / s);
 	}
-
+  /**@brief Return a vector will the absolute values of each element */
 	SIMD_FORCE_INLINE btVector3 absolute() const 
 	{
 		return btVector3(
@@ -114,7 +143,8 @@
 			btFabs(m_y), 
 			btFabs(m_z));
 	}
-
+  /**@brief Return the cross product between this and another vector 
+   * @param v The other vector */
 	SIMD_FORCE_INLINE btVector3 cross(const btVector3& v) const
 	{
 		return btVector3(
@@ -130,11 +160,15 @@
 			m_z * (v1.x() * v2.y() - v1.y() * v2.x());
 	}
 
+  /**@brief Return the axis with the smallest value 
+   * Note return values are 0,1,2 for x, y, or z */
 	SIMD_FORCE_INLINE int minAxis() const
 	{
 		return m_x < m_y ? (m_x < m_z ? 0 : 2) : (m_y < m_z ? 1 : 2);
 	}
 
+  /**@brief Return the axis with the largest value 
+   * Note return values are 0,1,2 for x, y, or z */
 	SIMD_FORCE_INLINE int maxAxis() const 
 	{
 		return m_x < m_y ? (m_y < m_z ? 2 : 1) : (m_x < m_z ? 2 : 0);
@@ -160,6 +194,9 @@
 		//		m_co[3] = s * v0[3] + rt * v1[3];
 	}
 
+  /**@brief Return the linear interpolation between this and another vector 
+   * @param v The other vector 
+   * @param t The ration of this to v (t = 0 => return this, t=1 => return other) */
 	SIMD_FORCE_INLINE btVector3 lerp(const btVector3& v, const btScalar& t) const 
 	{
 		return btVector3(m_x + (v.x() - m_x) * t,
@@ -167,7 +204,8 @@
 			m_z + (v.z() - m_z) * t);
 	}
 
-
+  /**@brief Elementwise multiply this vector by the other 
+   * @param v The other vector */
 	SIMD_FORCE_INLINE btVector3& operator*=(const btVector3& v)
 	{
 		m_x *= v.x(); m_y *= v.y(); m_z *= v.z();
@@ -178,42 +216,48 @@
 
 };
 
+/**@brief Return the sum of two vectors (Point symantics)*/
 SIMD_FORCE_INLINE btVector3 
 operator+(const btVector3& v1, const btVector3& v2) 
 {
 	return btVector3(v1.x() + v2.x(), v1.y() + v2.y(), v1.z() + v2.z());
 }
 
+/**@brief Return the elementwise product of two vectors */
 SIMD_FORCE_INLINE btVector3 
 operator*(const btVector3& v1, const btVector3& v2) 
 {
 	return btVector3(v1.x() * v2.x(), v1.y() * v2.y(), v1.z() * v2.z());
 }
 
+/**@brief Return the difference between two vectors */
 SIMD_FORCE_INLINE btVector3 
 operator-(const btVector3& v1, const btVector3& v2)
 {
 	return btVector3(v1.x() - v2.x(), v1.y() - v2.y(), v1.z() - v2.z());
 }
-
+/**@brief Return the negative of the vector */
 SIMD_FORCE_INLINE btVector3 
 operator-(const btVector3& v)
 {
 	return btVector3(-v.x(), -v.y(), -v.z());
 }
 
+/**@brief Return the vector scaled by s */
 SIMD_FORCE_INLINE btVector3 
 operator*(const btVector3& v, const btScalar& s)
 {
 	return btVector3(v.x() * s, v.y() * s, v.z() * s);
 }
 
+/**@brief Return the vector scaled by s */
 SIMD_FORCE_INLINE btVector3 
 operator*(const btScalar& s, const btVector3& v)
 { 
 	return v * s; 
 }
 
+/**@brief Return the vector inversely scaled by s */
 SIMD_FORCE_INLINE btVector3
 operator/(const btVector3& v, const btScalar& s)
 {
@@ -221,12 +265,14 @@
 	return v * (btScalar(1.0) / s);
 }
 
+/**@brief Return the vector inversely scaled by s */
 SIMD_FORCE_INLINE btVector3
 operator/(const btVector3& v1, const btVector3& v2)
 {
 	return btVector3(v1.x() / v2.x(),v1.y() / v2.y(),v1.z() / v2.z());
 }
 
+/**@brief Return the dot product between two vectors */
 SIMD_FORCE_INLINE btScalar 
 dot(const btVector3& v1, const btVector3& v2) 
 { 
@@ -234,7 +280,7 @@
 }
 
 
-
+/**@brief Return the distance squared between two vectors */
 SIMD_FORCE_INLINE btScalar
 distance2(const btVector3& v1, const btVector3& v2) 
 { 
@@ -242,18 +288,21 @@
 }
 
 
+/**@brief Return the distance between two vectors */
 SIMD_FORCE_INLINE btScalar
 distance(const btVector3& v1, const btVector3& v2) 
 { 
 	return v1.distance(v2); 
 }
 
+/**@brief Return the angle between two vectors */
 SIMD_FORCE_INLINE btScalar
 angle(const btVector3& v1, const btVector3& v2) 
 { 
 	return v1.angle(v2); 
 }
 
+/**@brief Return the cross product of two vectors */
 SIMD_FORCE_INLINE btVector3 
 cross(const btVector3& v1, const btVector3& v2) 
 { 
@@ -266,13 +315,17 @@
 	return v1.triple(v2, v3);
 }
 
+/**@brief Return the linear interpolation between two vectors
+ * @param v1 One vector 
+ * @param v2 The other vector 
+ * @param t The ration of this to v (t = 0 => return v1, t=1 => return v2) */
 SIMD_FORCE_INLINE btVector3 
 lerp(const btVector3& v1, const btVector3& v2, const btScalar& t)
 {
 	return v1.lerp(v2, t);
 }
 
-
+/**@brief Test if each element of the vector is equivilent */
 SIMD_FORCE_INLINE bool operator==(const btVector3& p1, const btVector3& p2) 
 {
 	return p1.x() == p2.x() && p1.y() == p2.y() && p1.z() == p2.z();
Index: src/LinearMath/btQuadWord.h
===================================================================
--- src/LinearMath/btQuadWord.h	(revision 1343)
+++ src/LinearMath/btQuadWord.h	(working copy)
@@ -22,9 +22,9 @@
 
 
 
-///The btQuadWordStorage class is base class for btVector3 and btQuaternion. 
-///Some issues under PS3 Linux with IBM 2.1 SDK, gcc compiler prevent from using aligned quadword. todo: look into this
-///ATTRIBUTE_ALIGNED16(class) btQuadWordStorage
+/**@brief The btQuadWordStorage class is base class for btVector3 and btQuaternion. 
+ * Some issues under PS3 Linux with IBM 2.1 SDK, gcc compiler prevent from using aligned quadword. todo: look into this
+ * ATTRIBUTE_ALIGNED16(class) btQuadWordStorage */
 class btQuadWordStorage
 {
 protected:
@@ -39,34 +39,34 @@
 };
 
 
-///btQuadWord is base-class for vectors, points
+/** @brief btQuadWord is base-class for vectors, points */
 class	btQuadWord : public btQuadWordStorage
 {
 	public:
-	
+  
 //		SIMD_FORCE_INLINE btScalar&       operator[](int i)       { return (&m_x)[i];	}      
 //		SIMD_FORCE_INLINE const btScalar& operator[](int i) const { return (&m_x)[i]; }
-
+  /**@brief Return the x value */
 		SIMD_FORCE_INLINE const btScalar& getX() const { return m_x; }
-
+  /**@brief Return the y value */
 		SIMD_FORCE_INLINE const btScalar& getY() const { return m_y; }
-
+  /**@brief Return the z value */
 		SIMD_FORCE_INLINE const btScalar& getZ() const { return m_z; }
-
+  /**@brief Set the x value */
 		SIMD_FORCE_INLINE void	setX(btScalar x) { m_x = x;};
-
+  /**@brief Set the y value */
 		SIMD_FORCE_INLINE void	setY(btScalar y) { m_y = y;};
-
+  /**@brief Set the z value */
 		SIMD_FORCE_INLINE void	setZ(btScalar z) { m_z = z;};
-
+  /**@brief Set the w value */
 		SIMD_FORCE_INLINE void	setW(btScalar w) { m_unusedW = w;};
-
+  /**@brief Return the x value */
 		SIMD_FORCE_INLINE const btScalar& x() const { return m_x; }
-
+  /**@brief Return the y value */
 		SIMD_FORCE_INLINE const btScalar& y() const { return m_y; }
-
+  /**@brief Return the z value */
 		SIMD_FORCE_INLINE const btScalar& z() const { return m_z; }
-
+  /**@brief Return the w value */
 		SIMD_FORCE_INLINE const btScalar& w() const { return m_unusedW; }
 
 
@@ -74,7 +74,11 @@
 		SIMD_FORCE_INLINE	operator const btScalar *() const { return &m_x; }
 
 
-
+  /**@brief Set x,y,z and zero w 
+   * @param x Value of x
+   * @param y Value of y
+   * @param z Value of z
+   */
 		SIMD_FORCE_INLINE void 	setValue(const btScalar& x, const btScalar& y, const btScalar& z)
 		{
 			m_x=x;
@@ -90,6 +94,12 @@
 			m[2] = m_z;
 		}
 */
+/**@brief Set the values 
+   * @param x Value of x
+   * @param y Value of y
+   * @param z Value of z
+   * @param w Value of w
+   */
 		SIMD_FORCE_INLINE void	setValue(const btScalar& x, const btScalar& y, const btScalar& z,const btScalar& w)
 		{
 			m_x=x;
@@ -97,28 +107,40 @@
 			m_z=z;
 			m_unusedW=w;
 		}
-
+  /**@brief No initialization constructor */
 		SIMD_FORCE_INLINE btQuadWord()
 		//	:m_x(btScalar(0.)),m_y(btScalar(0.)),m_z(btScalar(0.)),m_unusedW(btScalar(0.))
 		{
 		}
-
+  /**@brief Copy constructor */
 		SIMD_FORCE_INLINE btQuadWord(const btQuadWordStorage& q)
 		{
 			*((btQuadWordStorage*)this) = q;
 		}
-
+  /**@brief Three argument constructor (zeros w)
+   * @param x Value of x
+   * @param y Value of y
+   * @param z Value of z
+   */
 		SIMD_FORCE_INLINE btQuadWord(const btScalar& x, const btScalar& y, const btScalar& z)		
 		{
 			m_x = x, m_y = y, m_z = z, m_unusedW = 0.0f;
 		}
 
+/**@brief Initializing constructor
+   * @param x Value of x
+   * @param y Value of y
+   * @param z Value of z
+   * @param w Value of w
+   */
 		SIMD_FORCE_INLINE btQuadWord(const btScalar& x, const btScalar& y, const btScalar& z,const btScalar& w) 
 		{
 			m_x = x, m_y = y, m_z = z, m_unusedW = w;
 		}
 
-
+  /**@brief Set each element to the max of the current values and the values of another btQuadWord
+   * @param other The other btQuadWord to compare with 
+   */
 		SIMD_FORCE_INLINE void	setMax(const btQuadWord& other)
 		{
 			btSetMax(m_x, other.m_x);
@@ -126,7 +148,9 @@
 			btSetMax(m_z, other.m_z);
 			btSetMax(m_unusedW, other.m_unusedW);
 		}
-
+  /**@brief Set each element to the min of the current values and the values of another btQuadWord
+   * @param other The other btQuadWord to compare with 
+   */
 		SIMD_FORCE_INLINE void	setMin(const btQuadWord& other)
 		{
 			btSetMin(m_x, other.m_x);
Index: src/LinearMath/btMinMax.h
===================================================================
--- src/LinearMath/btMinMax.h	(revision 1343)
+++ src/LinearMath/btMinMax.h	(working copy)
@@ -17,24 +17,32 @@
 #ifndef GEN_MINMAX_H
 #define GEN_MINMAX_H
 
+/**@brief Return the minimum of two values */
 template <class T>
 SIMD_FORCE_INLINE const T& btMin(const T& a, const T& b) 
 {
   return a < b ? a : b ;
 }
 
-template <class T>
+/**@brief Return the maximum of two values */template <class T>
 SIMD_FORCE_INLINE const T& btMax(const T& a, const T& b) 
 {
   return  a > b ? a : b;
 }
 
+/**@brief Return a clamped value
+ * @param a The value 
+ * @param lb The lower bound 
+ * @param ub The uppper bound */
 template <class T>
 SIMD_FORCE_INLINE const T& GEN_clamped(const T& a, const T& lb, const T& ub) 
 {
 	return a < lb ? lb : (ub < a ? ub : a); 
 }
 
+/**@brief Set a value to the min of itself and another 
+ * @param a The value to set
+ * @param b The other value  */
 template <class T>
 SIMD_FORCE_INLINE void btSetMin(T& a, const T& b) 
 {
@@ -44,6 +52,9 @@
 	}
 }
 
+/**@brief Set a value to the max of itself and another 
+ * @param a The value to set
+ * @param b The other value  */
 template <class T>
 SIMD_FORCE_INLINE void btSetMax(T& a, const T& b) 
 {
@@ -53,6 +64,10 @@
 	}
 }
 
+/**@brief Clamp a value 
+ * @param a The value to clamp 
+ * @param lb The lower bound 
+ * @param ub The upper bound */
 template <class T>
 SIMD_FORCE_INLINE void GEN_clamp(T& a, const T& lb, const T& ub) 
 {
Index: src/LinearMath/btMatrix3x3.h
===================================================================
--- src/LinearMath/btMatrix3x3.h	(revision 1343)
+++ src/LinearMath/btMatrix3x3.h	(working copy)
@@ -23,14 +23,16 @@
 
 
 
-///The btMatrix3x3 class implements a 3x3 rotation matrix, to perform linear algebra in combination with btQuaternion, btTransform and btVector3.
-///Make sure to only include a pure orthogonal matrix without scaling.
+/**@brief The btMatrix3x3 class implements a 3x3 rotation matrix, to perform linear algebra in combination with btQuaternion, btTransform and btVector3.
+ * Make sure to only include a pure orthogonal matrix without scaling. */
 class btMatrix3x3 {
 	public:
+  /** @brief No initializaion constructor */
 		btMatrix3x3 () {}
 		
 //		explicit btMatrix3x3(const btScalar *m) { setFromOpenGLSubMatrix(m); }
 		
+  /**@brief Constructor from Quaternion */
 		explicit btMatrix3x3(const btQuaternion& q) { setRotation(q); }
 		/*
 		template <typename btScalar>
@@ -39,6 +41,7 @@
 			setEulerYPR(yaw, pitch, roll);
 		}
 		*/
+  /** @brief Constructor with row major formatting */
 		btMatrix3x3(const btScalar& xx, const btScalar& xy, const btScalar& xz,
 				  const btScalar& yx, const btScalar& yy, const btScalar& yz,
 				  const btScalar& zx, const btScalar& zy, const btScalar& zz)
@@ -47,14 +50,14 @@
 					 yx, yy, yz, 
 					 zx, zy, zz);
 		}
-		
+  /** @brief Copy constructor */
 		SIMD_FORCE_INLINE btMatrix3x3 (const btMatrix3x3& other)
 		{
 			m_el[0] = other.m_el[0];
 			m_el[1] = other.m_el[1];
 			m_el[2] = other.m_el[2];
 		}
-
+  /** @brief Assignment Operator */
 		SIMD_FORCE_INLINE btMatrix3x3& operator=(const btMatrix3x3& other)
 		{
 			m_el[0] = other.m_el[0];
@@ -63,34 +66,45 @@
 			return *this;
 		}
 
+  /** @brief Get a column of the matrix as a vector 
+   *  @param i Column number 0 indexed */
 		SIMD_FORCE_INLINE btVector3 getColumn(int i) const
 		{
 			return btVector3(m_el[0][i],m_el[1][i],m_el[2][i]);
 		}
 		
 
-
+  /** @brief Get a row of the matrix as a vector 
+   *  @param i Row number 0 indexed */
 		SIMD_FORCE_INLINE const btVector3& getRow(int i) const
 		{
+			btFullAssert(0 <= i && i < 3);
 			return m_el[i];
 		}
 
-
+  /** @brief Get a mutable reference to a row of the matrix as a vector 
+   *  @param i Row number 0 indexed */
 		SIMD_FORCE_INLINE btVector3&  operator[](int i)
 		{ 
 			btFullAssert(0 <= i && i < 3);
 			return m_el[i]; 
 		}
 		
+  /** @brief Get a const reference to a row of the matrix as a vector 
+   *  @param i Row number 0 indexed */
 		SIMD_FORCE_INLINE const btVector3& operator[](int i) const
 		{
 			btFullAssert(0 <= i && i < 3);
 			return m_el[i]; 
 		}
 		
+  /** @brief Multiply by the target matrix on the right
+   *  @param m Rotation matrix to be applied 
+   * Equivilant to this = this * m */
 		btMatrix3x3& operator*=(const btMatrix3x3& m); 
 		
-	
+  /** @brief Set from a carray of btScalars 
+   *  @param m A pointer to the beginning of an array of 9 btScalars */
 	void setFromOpenGLSubMatrix(const btScalar *m)
 		{
 			m_el[0].setValue(m[0],m[4],m[8]);
@@ -98,7 +112,16 @@
 			m_el[2].setValue(m[2],m[6],m[10]);
 
 		}
-
+  /** @brief Set the values of the matrix explicitly (row major)
+   *  @param xx Top left
+   *  @param xy Top Middle
+   *  @param xz Top Right
+   *  @param yx Middle Left
+   *  @param yy Middle Middle
+   *  @param yz Middle Right
+   *  @param zx Bottom Left
+   *  @param zy Bottom Middle
+   *  @param zz Bottom Right*/
 		void setValue(const btScalar& xx, const btScalar& xy, const btScalar& xz, 
 					  const btScalar& yx, const btScalar& yy, const btScalar& yz, 
 					  const btScalar& zx, const btScalar& zy, const btScalar& zz)
@@ -107,7 +130,9 @@
 			m_el[1].setValue(yx,yy,yz);
 			m_el[2].setValue(zx,zy,zz);
 		}
-  
+
+  /** @brief Set the matrix from a quaternion
+   *  @param q The Quaternion to match */  
 		void setRotation(const btQuaternion& q) 
 		{
 			btScalar d = q.length2();
@@ -123,7 +148,11 @@
 		}
 		
 
-
+  /** @brief Set the matrix from euler angles using YPR around YXZ respectively
+   *  @param yaw Yaw about Y axis
+   *  @param pitch Pitch about X axis
+   *  @param roll Roll about Z axis 
+   */
 		void setEulerYPR(const btScalar& yaw, const btScalar& pitch, const btScalar& roll) 
 		{
 
@@ -143,15 +172,17 @@
 		
 		}
 
-	/**
-	 * setEulerZYX
-	 * @param euler a const reference to a btVector3 of euler angles
+	/** @brief Set the matrix from euler angles YPR around ZYX axes
+	 * @param eulerX Roll about X axis
+         * @param eulerY Pitch around Y axis
+         * @param eulerZ Yaw aboud Z axis
+         * 
 	 * These angles are used to produce a rotation matrix. The euler
 	 * angles are applied in ZYX order. I.e a vector is first rotated 
 	 * about X then Y and then Z
 	 **/
-	
-	void setEulerZYX(btScalar eulerX,btScalar eulerY,btScalar eulerZ) {
+	void setEulerZYX(btScalar eulerX,btScalar eulerY,btScalar eulerZ) { 
+  ///@todo proposed to reverse this since it's labeled zyx but takes arguments xyz and it will match all other parts of the code
 		btScalar ci ( btCos(eulerX)); 
 		btScalar cj ( btCos(eulerY)); 
 		btScalar ch ( btCos(eulerZ)); 
@@ -168,13 +199,15 @@
 	       			 -sj,      cj * si,      cj * ci);
 	}
 
+  /**@brief Set the matrix to the identity */
 		void setIdentity()
 		{ 
 			setValue(btScalar(1.0), btScalar(0.0), btScalar(0.0), 
 					 btScalar(0.0), btScalar(1.0), btScalar(0.0), 
 					 btScalar(0.0), btScalar(0.0), btScalar(1.0)); 
 		}
-    
+  /**@brief Fill the values of the matrix into a 9 element array 
+   * @param m The array to be filled */
 		void getOpenGLSubMatrix(btScalar *m) const 
 		{
 			m[0]  = btScalar(m_el[0].x()); 
@@ -191,6 +224,8 @@
 			m[11] = btScalar(0.0); 
 		}
 
+  /**@brief Get the matrix represented as a quaternion 
+   * @param q The quaternion which will be set */
 		void getRotation(btQuaternion& q) const
 		{
 			btScalar trace = m_el[0].x() + m_el[1].y() + m_el[2].z();
@@ -224,7 +259,11 @@
 			}
 			q.setValue(temp[0],temp[1],temp[2],temp[3]);
 		}
-	
+
+  /**@brief Get the matrix represented as euler angles around YXZ
+   * @param yaw Yaw around Y axis
+   * @param pitch Pitch around X axis
+   * @param roll around Z axis */	
 		void getEuler(btScalar& yaw, btScalar& pitch, btScalar& roll) const
 		{
 			
@@ -251,8 +290,75 @@
 			}
 		}
 		
+  /**@brief Get the matrix represented as euler angles around ZYX
+   * @param yaw Yaw around X axis
+   * @param pitch Pitch around Y axis
+   * @param roll around X axis 
+   * @param solution_number Which solution of two possible solutions ( 1 or 2) are possible values*/	
+  void getEulerZYX(btScalar& yaw, btScalar& pitch, btScalar& roll, unsigned int solution_number = 1) const
+  {
+    struct Euler{btScalar yaw, pitch, roll;};
+    Euler euler_out;
+    Euler euler_out2; //second solution
+    //get the pointer to the raw data
+    
+    // Check that pitch is not at a singularity
+    if (btFabs(m_el[2].x()) >= 1)
+    {
+      euler_out.yaw = 0;
+      euler_out2.yaw = 0;
+	
+      // From difference of angles formula
+      double delta = btAtan2(m_el[0].x(),m_el[0].z());
+      if (m_el[2].x() > 0)  //gimbal locked up
+      {
+        euler_out.pitch = M_PI / 2.0;
+        euler_out2.pitch = M_PI / 2.0;
+        euler_out.roll = euler_out.pitch + delta;
+        euler_out2.roll = euler_out.pitch + delta;
+      }
+      else // gimbal locked down
+      {
+        euler_out.pitch = -M_PI / 2.0;
+        euler_out2.pitch = -M_PI / 2.0;
+        euler_out.roll = -euler_out.pitch + delta;
+        euler_out2.roll = -euler_out.pitch + delta;
+      }
+    }
+    else
+    {
+      euler_out.pitch = - btAsin(m_el[2].x());
+      euler_out2.pitch = M_PI - euler_out.pitch;
+	
+      euler_out.roll = btAtan2(m_el[2].y()/cos(euler_out.pitch), 
+			       m_el[2].z()/cos(euler_out.pitch));
+      euler_out2.roll = btAtan2(m_el[2].y()/cos(euler_out2.pitch), 
+				m_el[2].z()/cos(euler_out2.pitch));
+	
+      euler_out.yaw = btAtan2(m_el[1].x()/cos(euler_out.pitch), 
+			      m_el[0].x()/cos(euler_out.pitch));
+      euler_out2.yaw = btAtan2(m_el[1].x()/cos(euler_out2.pitch), 
+                               m_el[0].x()/cos(euler_out2.pitch));
+    }
+    
+    if (solution_number == 1)
+    { yaw = euler_out.yaw; 
+    pitch = euler_out.pitch;
+    roll = euler_out.roll;
+    }
+    else
+    { yaw = euler_out2.yaw; 
+    pitch = euler_out2.pitch;
+    roll = euler_out2.roll;
+    }
 
-	
+
+    return;
+
+  }
+
+  /**@brief Create a scaled copy of the matrix 
+   * @param s Scaling vector The elements of the vector will scale each column */
 		
 		btMatrix3x3 scaled(const btVector3& s) const
 		{
@@ -261,10 +367,15 @@
 									 m_el[2].x() * s.x(), m_el[2].y() * s.y(), m_el[2].z() * s.z());
 		}
 
+  /**@brief Return the determinant of the matrix */
 		btScalar            determinant() const;
+  /**@brief Return the adjoint of the matrix */
 		btMatrix3x3 adjoint() const;
+  /**@brief Return the matrix with all values non negative */
 		btMatrix3x3 absolute() const;
+  /**@brief Return the transpose of the matrix */
 		btMatrix3x3 transpose() const;
+  /**@brief Return the inverse of the matrix */
 		btMatrix3x3 inverse() const; 
 		
 		btMatrix3x3 transposeTimes(const btMatrix3x3& m) const;
@@ -284,12 +395,15 @@
 		}
 		
 
-		///diagonalizes this matrix by the Jacobi method. rot stores the rotation
-		///from the coordinate system in which the matrix is diagonal to the original
-		///coordinate system, i.e., old_this = rot * new_this * rot^T. The iteration
-		///stops when all off-diagonal elements are less than the threshold multiplied
-		///by the sum of the absolute values of the diagonal, or when maxSteps have
-		///been executed. Note that this matrix is assumed to be symmetric.
+  /**@brief diagonalizes this matrix by the Jacobi method.
+   * @param rot stores the rotation from the coordinate system in which the matrix is diagonal to the original
+   * coordinate system, i.e., old_this = rot * new_this * rot^T. 
+   * @param threshold See iteration
+   * @param iteration The iteration stops when all off-diagonal elements are less than the threshold multiplied 
+   * by the sum of the absolute values of the diagonal, or when maxSteps have been executed. 
+   * 
+   * Note that this matrix is assumed to be symmetric. 
+   */
 		void diagonalize(btMatrix3x3& rot, btScalar threshold, int maxSteps)
 		{
 		 rot.setIdentity();
@@ -371,11 +485,18 @@
 
 		
 	protected:
+  /**@brief Calculate the matrix cofactor 
+   * @param r1 The first row to use for calculating the cofactor
+   * @param c1 The first column to use for calculating the cofactor
+   * @param r1 The second row to use for calculating the cofactor
+   * @param c1 The second column to use for calculating the cofactor
+   * See http://en.wikipedia.org/wiki/Cofactor_(linear_algebra) for more details
+   */
 		btScalar cofac(int r1, int c1, int r2, int c2) const 
 		{
 			return m_el[r1][c1] * m_el[r2][c2] - m_el[r1][c2] * m_el[r2][c1];
 		}
-
+  ///Data storage for the matrix, each vector is a row of the matrix
 		btVector3 m_el[3];
 	};
 	
@@ -494,6 +615,8 @@
 }
 */
 
+/**@brief Equality operator between two matrices
+ * It will test all elements are equal.  */
 SIMD_FORCE_INLINE bool operator==(const btMatrix3x3& m1, const btMatrix3x3& m2)
 {
    return ( m1[0][0] == m2[0][0] && m1[1][0] == m2[1][0] && m1[2][0] == m2[2][0] &&
