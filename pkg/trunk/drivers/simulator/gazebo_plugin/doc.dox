/**
@mainpage

@htmlinclude manifest.html

Here are the gazebo plugins which are currently implemented:
 \li \ref gazebo::GazeboActuators "ROS Mechanism Controls Plugin for Actuators"
 \li \ref gazebo::Ros_Time "ROS Time Plugin"
 \li \ref gazebo::Ros_Camera "ROS Camera Plugin"
 \li \ref gazebo::Ros_Laser "ROS Laser Scanner Plugin"
 \li \ref gazebo::Ros_Block_Laser "ROS Block Laser Scanner Plugin"
 \li \ref gazebo::Ros_PTZ "ROS PTZ Camera Plugin"
 \li \ref gazebo::P3D "ROS Ground Truth Broadcaster"


 @image html gazebo_mcn.jpg "Gazebo Mechanism Control Model"

@section usage PR2 Simulation Quick Start Guide
\li If you have successfully \e rosmake \e 2dnav-gazebo, you have EVERYTHING needed to run all simulator+PR2 demos. Otherwise, to compile a minimum set of packages for running Gazebo:
  @verbatim
  $ rosmake gazebo
  $ rosmake gazebo_plugin
  $ rosmake gazebo_robot_description
  @endverbatim

\li Here is a simple launch script that starts Gazebo:
  @verbatim
  <launch>
    <!-- automatically start a new master if none active -->
    <master auto="start">
    <!-- if needed, group tag allows pushing components into namespace via attribute ns="namespace" -->
    <group name="wg">
      <!-- assign environment variables for gazebo and startup gazebo with argument containing the world file.  -->
      <node pkg="gazebo" type="gazebo" args="-n $(find gazebo_robot_description)/world/robot.world" respawn="false" output="screen">
        <env name="LD_LIBRARY_PATH" value="$(find gazebo_plugin)/lib:$(find gazebo)/gazebo/lib:$(find Cg)/Cg/lib:$LD_LIBRARY_PATH" />
        <env name="GAZEBO_RESOURCE_PATH" value="$(find gazebo_robot_description)/world" />
        <env name="OGRE_RESOURCE_PATH" value="$(find ogre)/ogre/lib/OGRE" />
        <env name="MC_RESOURCE_PATH" value="$(find gazebo_robot_description)/world" />
      </node>
     </group>
  </launch>
  @endverbatim
  see <a href="http://pr.willowgarage.com/wiki/roslaunch">roslaunch</a> for more details.

 - To start a mechanism::MechanismControlNode and spawn some controllers, you have to first send \b pr2.xml to the parameter server, then invoke \b mech.py with the controllers xml configuration file as the argument to spawn controllers:
  @verbatim
      <!-- send pr2.xml to parameter server as a string, allow retrieval by various components whe needs it
           (Mechanism Control, BaseControllerNode, etc...) -->
      <param name="robotdesc/pr2" command="$(find wg_robot_description_parser)/merge &quot;$(find wg_robot_description)/pr2/pr2.xml&quot;" />
      <!-- use mech.py to spawn all controllers listed in controllers.xml -->
      <node pkg="mechanism_control" type="mech.py" args="sp $(find wg_robot_description)/pr2/controllers.xml" respawn="false" output="screen" />
  @endverbatim

 - The following \b control.py node sends a \e set_profile command of 46 to the \b tilt_laser_controller:
  @verbatim
      <!-- start tilting Hokuyo laser by sending it a preset code of 46, this means sawtooth profile sweep.
           for details of the profile, rates, see controller::LaserScannerControllerNode. -->
      <node pkg="robot_mechanism_controllers" type="control.py" args="set tilt_laser_controller 46" respawn="false" output="screen" />
  @endverbatim

\li Alternatively, one can start gazebo manually (e.g. in bash):
  @verbatim
  $ export GAZ_TOP=`rospack find gazebo`/gazebo
  $ export OGRE_TOP=`rospack find ogre`/ogre
  $ export CG_TOP=`rospack find Cg`/Cg
  $ export SIM_PLUGIN=`rospack find gazebo_plugin`
  $ export PR2MEDIA=`rospack find gazebo_robot_description`/world
  $ export LD_LIBRARY_PATH=$SIM_PLUGIN/lib:$GAZ_TOP/lib:$CG_TOP/lib:$LD_LIBRARY_PATH
  $ export PATH=$GAZ_TOP/bin:$PATH
  $ export GAZEBO_RESOURCE_PATH=$PR2MEDIA
  $ export OGRE_RESOURCE_PATH=$OGRE_TOP/lib/OGRE
  $ export MC_RESOURCE_PATH=$PR2MEDIA
  $ gazebo `rospack find gazebo_robot_description`/world/robot.world
  @endverbatim

@section parameters Robot Descriptions
\li PR2 Robot Description
  Robot descriptions are explained in the <a href="http://pr.willowgarage.com/wiki/RobotDescriptionFormat">Robot Description Format</a> page.
  You can find the complete PR2 description file in \b ros-pkg/robot_descriptions/wg_robot_description/pr2/pr2.xml.
  - To convert \b pr2.xml into Gazebo recognizable format (\b ros-pkg/robot_descriptions/gazebo_robot_description) run the following commands:
    @verbatim
    $ roscd gazebo_robot_description
    $ rosmake
    @endverbatim
    thus generating \b ros-pkg/robot_descriptions/gazebo_robot_description/world/pr2_xml.model.  The \e .model-file
    is included by the gazebo world file: \b ros-pkg/robot_descriptions/gazebo_robot_description/world/robot.world.

\li Another Example: Simple Robot (Not really a robot, single link only)
  Here is an example demonstrating a simple mechanism control / controller stack for a single DOF
  (You can find the equivalent version in \b ros-pkg/robot_descriptions/wg_robot_description/single_link_test).
  - \b pr2_single_link.xml
    @verbatim
      <?xml version="1.0"?>

      <robot name="pr2"><!-- name of the robot-->
        
        <!-- joint blocks -->
        <joint name="single_link_joint" type="revolute" >
          <axis xyz="1 0 0" />
          <anchor xyz="0 0 0" />
          <limit min="-M_PI" max="M_PI" effort="100" velocity="5" />
          <calibration values="1.5 -1 " />
        </joint>
        
        <joint name="base_block_joint" type="planar"> 
        </joint>

        <!-- link blocks -->
        <link name="base_block">
          <parent name="world" />
          <origin xyz="0 0 0.002 " rpy="0 0 0" />
          <joint name="base_block_joint" />
          <inertial>
            <mass value="1000" />
            <com xyz="0 0 0" />
            <inertia ixx="1000"  ixy="0"  ixz="0" iyy="1000" iyz="0" izz="1000" />
          </inertial> 
          <visual>
            <origin xyz="0 0 0" rpy="0 0 0" />
            <map name="gazebo_material" flag="gazebo">
              <elem key="material">Gazebo/GrassFloor</elem>
            </map>
            <geometry name="base_block_visual_geom">
              <mesh scale="20 20 0.1" />
            </geometry>
          </visual> 
          <collision>
            <origin xyz="0 0 0" rpy="0.0 0.0 0.0" />
            <geometry name="base_block_collision_geom">
              <box size="20 20 0.1" />
            </geometry>
          </collision>
        </link>
        
        <link name="single_link">
          <parent name="base_block" />
          <origin xyz="0 0 1" rpy="0 0 0" />
          <joint name="single_link_joint" />
          <inertial >
            <mass value="10" />
            <com xyz="0 0 0" /> 
            <inertia  ixx="0.1" ixy="0.0"  ixz="0.0"  iyy="0.1"  iyz="0.0"  izz="0.1" />
          </inertial>
          <visual >
            <origin xyz="0 0 0" rpy="0 0 0" />
            <map name="gazebo_material" flag="gazebo">
              <elem key="material">Gazebo/Red</elem>
            </map>
            <geometry name="sholder_roll_mesh_file">
              <mesh scale="1.0 0.1 0.1" />
            </geometry>
          </visual>
          <collision >
            <origin xyz="0.5 0 0" rpy="0.0 0.0 0.0 " />
            <geometry name="single_link_collision_geom">
              <box size="1.0 0.1 0.1" />
            </geometry>
          </collision>
          <map name="single_link_gravity" flag="gazebo">
            <elem key="turnGravityOff">true</elem>
          </map>
        </link>
        <!-- Define groups of links; a link may be part of multiple groups -->
        <include>groups_single_link.xml</include>
        <!-- mechanism controls -->
        <include>actuators_single_link.xml</include> 
        <include>transmissions_single_link.xml</include> 

        <!-- setup for GazeboActuators plugin -->
        <map name="transmissions_gazebo_actuators" flag="gazebo"> <!-- we can set a name too, but the convertor only cares about the flag -->
          <verbatim key="transmissions_gazebo_actuators" includes="true"> <!-- The key attribute is needed noly if multiple <xml> tags are in the same <map> tag -->
          <!-- PR2_ACTARRAY -->
          <controller:gazebo_actuators name="gazebo_actuators" plugin="libgazebo_actuators.so">
            <alwaysOn>true</alwaysOn>
            <updateRate>100.0</updateRate>
            <robot filename="pr2_single_link.xml" />
            <gazebo_physics filename="gazebo_joints_single_link.xml" /> <!-- for simulator/physics specific settigs -->
            <interface:audio name="gazebo_actuators_dummy_iface" />
          </controller:gazebo_actuators>
          </verbatim>
        </map>
        <!-- setup for a ground truth widget, returns pose/rate information over ROS via P3D plugin -->
        <map name="controllers" flag="gazebo"> <!-- we can set a name too, but the convertor only cares about the flag -->
          <verbatim key="controllers"> <!-- The key attribute is needed noly if multiple <xml> tags are in the same <map> tag -->

          <!-- P3D for position groundtruth -->
          <controller:P3D name="p3d_single_link_controller" plugin="libP3D.so">
              <alwaysOn>true</alwaysOn>
              <updateRate>100.0</updateRate>
              <bodyName>single_link</bodyName>
              <topicName>single_link_pose</topicName>
              <frameName>single_link_frame</frameName>
              <interface:position name="p3d_single_link_position"/>
          </controller:P3D>

          </verbatim>
        </map>
      </robot>
    @endverbatim
   - where \b gazebo_joints_single_link.xml specifies damping of the joint
    @verbatim
      <robot name="pr2">
        <joint name="single_link_joint" >
            <explicitDampingCoefficient>1</explicitDampingCoefficient>
        </joint>
      </robot>
    @endverbatim
   - \b groups_single_link.xml is used by kinematics library to construct a kinematic chain, though meaningless in this example.
    @verbatim
      <?xml version="1.0"?>
      <robot name="pr2"><!-- name of the robot-->
        <group name="my_group" flags="planning kinematic">
          roll_link
        </group>
      </robot>
    @endverbatim
   - \b actuators_single_link.xml
    @verbatim
      <?xml version="1.0"?>
      <robot name="pr2"><!-- name of the robot-->
        <actuator name="single_link_motor">
          <motorboardID>12345</motorboardID>
          <maxCurrent>5</maxCurrent>
          <motor>MAXON</motor>
          <ip> 10.12.0.103 </ip> 
          <port> 0 </port>
          <reduction>10</reduction>
          <polymap>-1 -0.2 -0.5 </polymap>
        </actuator>
      </robot>
    @endverbatim
   - \b transmissions_single_link.xml
    @verbatim
      <?xml version="1.0"?>
      <robot name="pr2"><!-- name of the robot-->
        <transmission type="SimpleTransmission" name="single_link_trans">
          <actuator name="single_link_motor" />
          <joint name="single_link_joint" />
          <mechanicalReduction>1</mechanicalReduction>
          <motorTorqueConstant>1</motorTorqueConstant>
          <pulsesPerRevolution>90000</pulsesPerRevolution>
        </transmission>
      </robot>
    @endverbatim
   - here's a simple controller xml to control the single link \bcontroller_single_link.xml:
    @verbatim
      <?xml version="1.0"?>
      <controllers>
        <controller name="test_controller" topic="single_link_controller" type="JointPositionControllerNode">
          <joint name="single_link_joint" >
            <pid p="2000" d="200" i="0.1" iClamp="1" />
          </joint>
        </controller>
      </controllers>
    @endverbatim
   - and finally, to run it all, a roslaunch script can be found in \b ros-pkg/robot_descriptions/gazebo_robot_description/single_link.xml:
    @verbatim
      <launch>
        <group name="wg">
          <param name="robotdesc/pr2" command="$(find wg_robot_description_parser)/merge &quot;$(find wg_robot_description)/single_link_test/pr2_single_link.xml&quot;" />
          <node pkg="gazebo" type="gazebo" args="$(find gazebo_robot_description)/world/robot_single_link.world" respawn="false" output="screen">
            <env name="LD_LIBRARY_PATH" value="$(find gazebo_plugin)/lib:$(find gazebo)/gazebo/lib:$(find Cg)/Cg/lib:$LD_LIBRARY_PATH" />
            <env name="GAZEBO_RESOURCE_PATH" value="$(find gazebo_robot_description)/world" />
            <env name="OGRE_RESOURCE_PATH" value="$(find ogre)/ogre/lib/OGRE" />
            <env name="MC_RESOURCE_PATH" value="$(find gazebo_robot_description)/world" />
          </node>
        </group>
        <!-- startup a single controller -->
        <node pkg="mechanism_control" type="mech.py" args="sp $(find wg_robot_description)/single_link_test/controllers_single_link.xml" respawn="false" output="screen" />
        <!-- set controller to .5 radians -->
        <node pkg="robot_mechanism_controllers" type="control.py" args="set test_controller 0.5" respawn="false" output="screen" />
      </launch>
    @endverbatim

@section topic PR2 ROS topics
Various dynamically loaded plugins have been outfitted for PR2.
Below are the ROS messages actively used by PR2 simulation as described by launch script \b roslaunch \b ros-pkg/robot_descriptions/gazebo_robot_description/pr2_gazebo_actuators.xml.

 - ROS topics published by the simulator
     <table border="1">
     <tr><th>  Component    </th>  <th>  Topic Name                          </th> <th> Message Type                         </th>  <th> Plugin Name             </th> </tr>
     <tr><th>  images       </th>  <th> wrist_left/image                     </th> <th>  std_msgs::Image.msg                 </th>  <th>  Ros_Camera.hh          </th> </tr>
     <tr><th>  images       </th>  <th> wrist_right/image                    </th> <th>  std_msgs::Image.msg                 </th>  <th>  Ros_Camera.hh          </th> </tr>
     <tr><th>  images       </th>  <th> forearm_left/image                   </th> <th>  std_msgs::Image.msg                 </th>  <th>  Ros_Camera.hh          </th> </tr>
     <tr><th>  images       </th>  <th> forearm_right/image                  </th> <th>  std_msgs::Image.msg                 </th>  <th>  Ros_Camera.hh          </th> </tr>
     <tr><th>  images       </th>  <th> axis_right/image                     </th> <th>  std_msgs::Image.msg                 </th>  <th>  Ros_Camera.hh          </th> </tr>
     <tr><th>  images       </th>  <th> axis_left/image                      </th> <th>  std_msgs::Image.msg                 </th>  <th>  Ros_Camera.hh          </th> </tr>
     <tr><th>  images       </th>  <th> stereo_left/image                    </th> <th>  std_msgs::Image.msg                 </th>  <th>  Ros_Camera.hh          </th> </tr>

     <tr><th>  scans        </th>  <th> base_scan                            </th> <th>  std_msgs::LaserScan.msg             </th>  <th>  Ros_Laser.hh           </th> </tr>
     <tr><th>  scans        </th>  <th> tilt_scan                            </th> <th>  std_msgs::LaserScan.msg             </th>  <th>  Ros_Laser.hh           </th> </tr>

     <tr><th> point_clouds  </th>  <th> full_cloud                           </th> <th>  std_msgs::PointCloudFloat32.msg     </th>  <th>  Ros_Block_Laser.hh     </th> </tr>

     <tr><th> battery       </th>  <th> battery_state                        </th> <th>  robot_msgs::BatteryStzte            </th>  <th>  gazebo_battery.h       </th> </tr>
     <tr><th> battery       </th>  <th> diagnostic                           </th> <th>  robot_msgs::DiagnosticMessage       </th>  <th>  gazebo_battery.h       </th> </tr>

     <tr><th> ground truths </th>  <th> base_pose_ground_truth               </th> <th>  std_msgs::TransformWithRateStamped  </th>  <th> P3D.hh                  </th> </tr>
     <tr><th> ground truths </th>  <th> gripper_roll_right_pose_ground_truth </th> <th>  std_msgs::TransformWithRateStamped  </th>  <th> P3D.hh                  </th> </tr>
     <tr><th> ground truths </th>  <th> gripper_roll_left_pose_ground_truth  </th> <th>  std_msgs::TransformWithRateStamped  </th>  <th> P3D.hh                  </th> </tr>
     <tr><th> ground truths </th>  <th> finger_tip_l_left_ground_truth       </th> <th>  std_msgs::TransformWithRateStamped  </th>  <th> P3D.hh                  </th> </tr>
     <tr><th> ground truths </th>  <th> finger_tip_r_left_ground_truth       </th> <th>  std_msgs::TransformWithRateStamped  </th>  <th> P3D.hh                  </th> </tr>
     <tr><th> ground truths </th>  <th> finger_tip_l_right_ground_truth      </th> <th>  std_msgs::TransformWithRateStamped  </th>  <th> P3D.hh                  </th> </tr>
     <tr><th> ground truths </th>  <th> finger_tip_R_right_ground_truth      </th> <th>  std_msgs::TransformWithRateStamped  </th>  <th> P3D.hh                  </th> </tr>
     <tr><th> PTZ cameras   </th>  <th> axis_right/ptz_state                 </th> <th>  std::string                         </th>  <th> Ros_PTZ.hh              </th> </tr>
     <tr><th> PTZ cameras   </th>  <th> axis_left/ptz_state                  </th> <th>  std::string                         </th>  <th> Ros_PTZ.hh              </th> </tr>
     <tr><th> time          </th>  <th> time                                 </th> <th>  rostools::Time                      </th>  <th> Ros_Time.hh             </th> </tr>
     </table border><br>
 - ROS topics published by mechanism control node
  - mechanism state:
   - \b mechanism_state, mechanism_control::MechanismState, mechanism_control.h
  - frame transforms:
   - \b TransformArray, rosTF::TransformArray, mechanism_control.h
 - ROS topics published by controllers
  - base controller:
   - \b odom
 - ROS topics subscribed by controllers
  - base controller:
   - \e cmd_vel
  - PTZ cameras:
   - \e axis_right/ptz_cmd
   - \e axis_left/ptz_cmd
  - arm position controllers:
   - \e left_arm_commands
   - \e right_arm_commands
  - joint position controllers:
   - \e left_gripper_commands
   - \e right_gripper_commands
   - \e head_pan_commands
   - \e head_tilt_commands
 - ROS service published by the simulator
  - battery:
   - \b full_charge_energy
 - ROS service subscribed by the simulator
  - battery:
   - \e timeout
   - \e diagnostic_rate
   - \e battery_state_rate
 - ROS service publsihed by mechanism control
  - mechanism control node:
   - \b list_controllers
   - \b list_controller_types
   - \b spawn_controller
   - \b kill_controller
 - ROS service published by controllers
  - base controller node:
   - \b base_controller/set_command
   - \b base_controller/get_actual
  - joint position controller node:
   - \b torso_controller/set_command
   - \b torso_controller/get_actual
   - \b gripper_left_controller/set_command
   - \b gripper_left_controller/get_actual
   - \b gripper_right_controller/set_command
   - \b gripper_right_controller/get_actual
   - \b head_pan_controller/set_command
   - \b head_pan_controller/get_actual
   - \b head_tilt_controller/set_command
   - \b head_tilt_controller/get_actual
  - laser scanner controller
   - \b tilt_laser_controller/set_command
   - \b tilt_laser_controller/get_actual
   - \b tilt_laser_controller/set_profile
  - arm position controller node:
   - \b left_arm_controller/set_command
   - \b left_arm_controller/set_command_array
   - \b left_arm_controller/get_command
   - \b left_arm_controller/set_target
   - \b right_arm_controller/set_command
   - \b right_arm_controller/set_command_array
   - \b right_arm_controller/get_command
   - \b right_arm_controller/set_target

@section templates How To Construct Your Own ROS Gazebo Plugin
Here is a sample code for making a very simple plugin in Gazebo that publishes \c rostools::Time message over a ROS topic.
\li \b my_plugin.h:
@verbatim
#ifndef MY_PLUGIN_HH
#define MY_PLUGIN_HH

#include <gazebo/Controller.hh>
#include <gazebo/Body.hh>
#include <gazebo/World.hh>
#include <ros/node.h>
#include <rostools/Time.h>

namespace gazebo
{
  class my_plugin : public Controller
  {
    /// \brief Constructor
    /// \param parent The parent entity, must be a Model or a Sensor
    public: my_plugin(Entity *parent);

    /// \brief Destructor
    public: virtual ~my_plugin();

    /// \brief Load the controller
    /// \param node XML config node
    protected: virtual void LoadChild(XMLConfigNode *node);

    /// \brief Init the controller
    protected: virtual void InitChild();

    /// \brief Update the controller
    protected: virtual void UpdateChild();

    /// \brief Finalize the controller
    protected: virtual void FiniChild();

    /// \brief A mutex to lock access to fields that are used in message callbacks
    private: ros::thread::mutex lock_;
    /// \brief pointer to ROS node
    ros::node *rosnode_;
    rostools::Time my_message_;

    /// \brief For loading XML parameters
    private: ParamT<std::string> *my_topic_name_p_;

    /// \brief ROS topic name
    private:        std::string  *my_topic_name_;
  };
}
#endif
@endverbatim

\li \b my_plugin.cpp:
@verbatim
#include <gazebo/Global.hh>
#include <gazebo/XMLConfig.hh>
#include <gazebo/Simulator.hh>
#include <gazebo/gazebo.h>
#include <gazebo/GazeboError.hh>
#include <gazebo/ControllerFactory.hh>
#include <gazebo_plugin/my_plugin.h>

namespace gazebo {

  GZ_REGISTER_DYNAMIC_CONTROLLER("my_plugin", MyPlugin);

  ////////////////////////////////////////////////////////////////////////////////
  // Constructor
  MyPlugin::MyPlugin(Entity *parent)
      : Controller(parent)
  {

    // start a ROS node if it has not been started already
    rosnode_ = ros::g_node;
    int argc = 0;
    char** argv = NULL;
    if (rosnode_ == NULL)
    {
      ros::init(argc,argv);
      rosnode_ = new ros::node("ros_gazebo",ros::node::DONT_HANDLE_SIGINT);
      printf("-------------------- starting node in MyPlugin \n");
    }

    // Setup parameter loading from XML
    Param::Begin(&this->parameters);
    this->my_topic_name_p_ = new ParamT<std::string>("my_topicname","default_topic_name",0);
    Param::End();

  }

  ////////////////////////////////////////////////////////////////////////////////
  // Destructor
  MyPlugin::~MyPlugin()
  {
  }

  ////////////////////////////////////////////////////////////////////////////////
  // Load the controller
  void MyPlugin::LoadChild(XMLConfigNode *node)
  {
    // Load parameters from XML node
    this->my_topic_name_p_->Load(node);
    this->my_topic_name_ = this->my_topic_name_p_->GetValue();
  }

  ////////////////////////////////////////////////////////////////////////////////
  // Initialize the controller
  void MyPlugin::InitChild()
  {
    // Perform initializations
    rosnode_->advertise<rostools::Time>(this->my_topic_name_,10);
  }

  ////////////////////////////////////////////////////////////////////////////////
  // Update the controller
  void MyPlugin::UpdateChild()
  {
    // get time from simulator
    double current_time = Simulator::Instance()->GetSimTime();

    // publish time to ROS message
    this->lock_.lock();
    my_message_.rostime.sec  = (unsigned long)floor(current_time);
    my_message_.rostime.nsec = (unsigned long)floor(  1e9 * (  current_time - my_message_.rostime.sec) );
    rosnode_->publish(this->my_topic_name_,my_message_);
    this->lock_.unlock();
  }

  ////////////////////////////////////////////////////////////////////////////////
  // Finalize the controller
  void MyPlugin::FiniChild()
  {
    // unadvertise topic
    rosnode_->unadvertise(this->my_topic_name_);
  }
}


@endverbatim

\li The corresponding XML snippet required to setup the controller:
@verbatim
    <model:physical name="my_model">
      <controller:my_plugin name="my_plugin_name" plugin="libmy_plugin.so">
        <my_topicname>my_topic</my_topicname>
      </controller:my_plugin>
    </model:physical>
@endverbatim

**/
