\documentclass[12pt]{article}

\usepackage{makeidx}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{float}
\makeindex

% a todo macro                                                                  
\newcommand{\todo}[1]{\vspace{3 mm}\par \noindent {\textsc{ToDo}}\framebox{
\begin{minipage}[c]{1.0\hsize}\tt #1 \end{minipage}}\vspace{3mm}\par}

\floatstyle{ruled}
\newfloat{program}{thp}{lop}
\floatname{program}{Program}

\newfloat{struct}{thp}{lop}
\floatname{struct}{Data Structure}

\setcounter{tocdepth}{4}


\begin{document}
\title{libTF Manual}
\author{Tully Foote\\
\href{mailto:tfoote@willowgarage.com}{\texttt{tfoote at willowgarage.com}}}
\date{\today}
\maketitle

\tableofcontents
\pagebreak

\section{Overview}
litTF is designed to provide a simple interface for keeping track 
of coordinate transforms within a robotic framework.  
A simple case which was one of the driving design considerations was
the use of a sensor on an actuated platform.  In this case the sensor
will report data in the frame of the moving platform, but the data is much 
more useful in the world frame. To provide the transform libTF will be told 
the position of the platform periodically as it moves.  And when prompted libTF can 
provide the transform from the sensor frame to the world frame at the time when the
sensor data was acquired.  Not only will libTF will keep track of the transform between 
two coordinate frames, but it will also keep track of a whole tree of coordinate frames, 
and automatically chain transformations together between any two connected frames.  

\section{Transform Library}
This section will first provide an overview of terms and conventions followed
by the direct API calls necessary to interact with the library.  

\subsection{Terminology and Conventions}
\paragraph {Coodinate Frame}
\index{Coordinate Frame}
In this documentation the default 
will be a right handed system with X forward, Y left and Z up. 

\paragraph {Denavit-Hartenberg Parameters (DH Parameters)}
\index{Denavit-Hartenberg Parameters} 
DH Parameters are a way to concicely represent a rigid body tranformation in three dimentions.  
It has four parameters: length, twist, offset, and angle.  In addition to using the optimal 
amount of data to store the transformation, there are also optimized methods of chaining 
transformations together.  And lastly the parameters can directly represent rotary and prismatic
joints found on robotic arms.  
See \url{http://en.wikipedia.org/wiki/Denavit-Hartenberg_Parameters} for more details.  

\todo{reproduce labeled diagram a good example \url{http://uwf.edu/ria/robotics/robotdraw/DH_parm.htm}}

\paragraph {Euler Angles}
\index{Euler Angles}
For this library Euler angles are considered to be translations in x, y, z, followed by a rotation around z, y, x.
With the respective angular changes referred to as yaw, pitch and roll. 

\paragraph {Homogeneous Transformation Matrix}
\index{Homogeneous Transform}
Homogeneous Transformation Matrices are a simple way to manipulate 3D translations and rotations 
with standard matrix multiplication.  It is a composite of a standard 3x3 rotation matrix
(see \url{http://en.wikipedia.org/wiki/Rotation_matrix}) and a translation vector.  

Let $_1R_0$ be the 3x3 rotation matrix defined by the Euler angles $(yaw_0,pitch_0,roll_0)$ 
and let $_1T_0$ be the column vector $(x_0,y_0,z_0)^T$ representing the translation.  The combination 
of these two transformations results in the transformation of reference frame 0 to reference frame 1.

A point P in frame 1, $P_1$, can be transformed into frame 1, $P_0$, by the following:

\begin{equation}
\label{eqn:HT}
\begin{pmatrix}
P_0 \\
1
\end{pmatrix}
=
\begin{pmatrix}
_0R_1 & _0T_1 \\
1 & 1
\end{pmatrix}
\begin{pmatrix}
P_1 \\
1
\end{pmatrix}
\end{equation}

The net result is a 4x4 transformation matrix which does both the rotation and translation 
between coordinate frames. The basic approach is to use a 4x1 vector consisting of $(x,y,z,1)^T_1$ 
and by left multiplying by $_0A_1$ it will result in $(x',y',z',1)^T_1$.

The matrix library used within this library is Newmat10.


\paragraph {Newmat10}
\index{Newmat10}
Newmat10 is the matrix library used in this library.  Documentation for Newmat can be found at 
\url{http://www.robertnz.net/nm10.htm}.  

\paragraph {Point}
Within this documentation a point is considered a 3D representation of a position within a 
frame.  It is notated, as x, y, z.  

\paragraph {Time Representation}
libTF uses an \texttt{unsigned long long} (equivilant to a \texttt{uint64\_t}) to represent nanoseconds since the epoch(1970).  
It is named \texttt{ULLtime} for clarity.

rosTF converts automatically to the above representation from a time pair of seconds and nanoseconds since the epoch, to 
be consistant with the rest of ROS.  

\paragraph{Vector}
Within this library a vector is a representation of a direction.  It is represented with the components in 3 directions, 
x,y,z.  However when subject to transformation, a vector will only be subject to rotations and will remain attached to the 
origin.  For example a point (1,1,1) subject to a translation of 5 in the x direction and yawed by 90 degrees would end
at (5,1,1), while a vector (1,1,1) subject to the same transformation would be (-1,1,1).  

\subsubsection{Data Types}
\paragraph {Time}

\section{ROS Integration}
The libTF was designed to be used within the ROS architecture and to that end 
a ROS compatible wrapper has also been written.  This wrapper enables the library
to handle all the communication between seperate sources and users of transformations.
The API for this is defined below.



\section{Summary of Internal Mathematics}
This libarary uses quaternion notation as the internal representation
of coordinate transforms.  Transform information is stored in a linked 
list sorted by time.  When a transform is requested the closest two points 
on the linked list are found and then interpolated in time to generate the 
return value.  

\subsection{Storage}
The internal storage for the transforms consists of:
\begin{struct}[H]
\caption{libTF Internal Data Storage}
\begin{verbatim}
  double xtranslation;// The three components of translation
  double ytranslation;
  double ztranslation;
  double xrotation; // The three components of the rotation axis
  double yrotation;
  double zrotation;
  double w; // Omega
  unsigned long long time; //nano seconds since 1970
\end{verbatim}
\end{struct}


\subsection{Interpolation}
The interpolation method used in this library is Spherical Linear Interpolation
(SLERP). \index{SLERP} The standard formula for SLERP is defined in Equation \ref{eq:slerp}.
The inputs are points $p_0$ and $p_1$, and $t$ is the proportion to interpolate 
between $p_0$ and $p_1$, and $\Omega$ is the angle between the axis of the two quaternions. 

\begin{equation}
Slerp(p_0,p_1;t) = \frac{sin((1-t)\Omega)}{sin(\Omega)} * p_0 + \frac{sin(t*\Omega)}{sin(\Omega)} * p_1
\label{eq:slerp}
\end{equation}

\todo{add graphic}

\paragraph{Alternatives}
The SLERP technique was developed in 1985 by Ken Shoemake. \cite{SHOEMAKE} SLERP has been 
largely adopted in the field of computer graphics, however there have been many alternatives 
developed.  The advantages of SLERP are that it provides a constant speed solution 
along the shortest path over the 4D unit sphere.  This is not optimal in all cases however.
A good discussion of various alternatives is here \url{http://number-none.com/product/Understanding%20Slerp,%20Then%20Not%20Using%20It/index.html}. 
The approaches discussed above are normalized linear interpolation (nlerp), and 
log-quaternion linear interpolation (log-quaternion lerp). 
SLERP can be recursively called to do a cubic interpolation, called SQUAD for short.  
This is discussed at \url{http://www.sjbrown.co.uk/?article=quaternions}.


\subsection{Data Representation Conversion}
\subsubsection{Matrix to Quaternion}
\subsubsection{Quaternion to Matrix}
\subsubsection{DH Parameters to Matrix}
\subsubsection{Euler Angles to Matrix}

\section{Example Usage}
\subsection{Library}
%\begin{program}[H]
\begin{verbatim}
#include ``libTF/libTF.h''
#include <sys/time.h>

using namespace std;

int main(void)
{
  double dx,dy,dz,dyaw,dp,dr;
  TransformReference mTR;
  
  //Temporary Variables
  dx = dy= dz = 0;
  dyaw = dp = dr = 0.1;
  
  timeval temp_time_struct;
  gettimeofday(&temp_time_struct,NULL);
  unsigned long long atime = temp_time_struct.tv_sec * 1000000000ULL + (unsigned long long)temp_time_struct.tv_usec * 1000ULL;

  
  //Fill in some transforms
  //  mTR.setWithEulers(10,2,1,1,1,dyaw,dp,dr,atime); //Switching out for DH par
ams below
  mTR.setWithDH(10,2,1.0,1.0,1.0,dyaw,atime);
    //mTR.setWithEulers(2,3,1-1,1,1,dyaw,dp,dr,atime-1000);
   mTR.setWithEulers(2,3,1,1,1,dyaw,dp,dr,atime-100);
   mTR.setWithEulers(2,3,1,1,1,dyaw,dp,dr,atime-50);
   mTR.setWithEulers(2,3,1,1,1,dyaw,dp,dr,atime-1000);
   //mTR.setWithEulers(2,3,1+1,1,1,dyaw,dp,dr,atime+1000);
  mTR.setWithEulers(3,5,dx,dy,dz,dyaw,dp,dr,atime);
  mTR.setWithEulers(5,1,dx,dy,dz,dyaw,dp,dr,atime);
  mTR.setWithEulers(6,5,dx,dy,dz,dyaw,dp,dr,atime);
  mTR.setWithEulers(6,5,dx,dy,dz,dyaw,dp,dr,atime);
  mTR.setWithEulers(7,6,1,1,1,dyaw,dp,dr,atime);
  mTR.setWithDH(8,7,1.0,1.0,1.0,dyaw,atime);
  //mTR.setWithEulers(8,7,1,1,1,dyaw,dp,dr,atime); //Switching out for DH params
 above
  
  
  //Demonstrate InvalidFrame LookupException
  try
    {
      std::cout<< mTR.viewChain(10,9);
    }
  catch (TransformReference::LookupException &ex)
    {
      std::cout << ``Caught `` << ex.what()<<std::endl;
    }
  
  
  // See the list of transforms to get between the frames
  std::cout<<''Viewing (10,8):''<<std::endl;  
  std::cout << mTR.viewChain(10,8);
  
  
  //See the resultant transform
  std::cout <<''Calling getMatrix(10,8)''<<std::endl;
  NEWMAT::Matrix mat = mTR.getMatrix(10,8,atime);  
  std::cout << ``Result of getMatrix(10,8,atime):'' << std::endl << mat<< std::end
l;
  
  //Break the graph, making it loop and demonstrate catching MaxDepthException
  mTR.setWithEulers(6,7,dx,dy,dz,dyaw,dp,dr,atime);
  
  try {
    std::cout<<mTR.viewChain(10,8);
  }
  catch (TransformReference::MaxDepthException &ex)
    {
      std::cout <<''caught loop in graph''<<std::endl;
    }
  
  //Break the graph, making it disconnected, and demonstrate catching Connectivi
tyException
  mTR.setWithEulers(6,0,dx,dy,dz,dyaw,dp,dr,atime);

  try {
    std::cout<<mTR.viewChain(10,8);
  }
  catch (TransformReference::ConnectivityException &ex)
    {
      std::cout <<''caught unconnected frame''<<std::endl;
    }  
  return 0;
};

\end{verbatim}
%\end{program}

\subsection{ROS Implementation}

\subsubsection{Example Broadcaster}
\begin{verbatim}
#include "rosTF/rosTF.h"

class testServer : public ros::node
{
public:
  //constructor
  testServer() : ros::node("server"),count(2){
    pTFServer = new rosTFServer(*this);
  };

  //A pointer to the rosTFServer class
  rosTFServer * pTFServer;


  // A function to call to send data periodically
  void test () {
    pTFServer->sendEuler(5,count++,1,1,1,1,1,1,100000,100000);
    pTFServer->sendDH(5,count++,1,1,1,1,100000,100000);
    pTFServer->sendQuaternion(5,count++,1,1,1,1,1,1,1,100000,100000);
  };

private:
  int count;

};

int main(int argc, char ** argv)
{
  //Initialize ROS
  ros::init(argc, argv);

  //Construct/initialize the server
  testServer myTestServer;
  
  while(myTestServer.ok())
    {
      //Send some data
      myTestServer.test();
      sleep(1);
    }

  return 0;
};
\end{verbatim}

\subsubsection{Example Client}
\begin{verbatim}
#include "rosTF/rosTF.h"

class testListener : public ros::node
{
public:
  //constructor with name
  testListener() : ros::node("client") {
    pClient = new rosTFClient(*this);
  };

  //A pointer to the client library object  
  rosTFClient * pClient;

};


int main(int argc, char ** argv)
{
  //Initialize ROS
  ros::init(argc, argv);

  //Instantiate a local listener
  testListener testListener;
  
  //Nothing needs to be done except wait for a quit
  //The callbacks withing the listener class 
  //will take care of everything
  while(testListener.ok())
    {
      sleep(1);
    }

  return 0;
};
\end{verbatim}

\bibliographystyle{plain}
\bibliography{libTF_Manual}

\printindex
\end{document}

