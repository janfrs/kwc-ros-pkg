//Software License Agreement (BSD License)

//Copyright (c) 2008, Willow Garage, Inc.
//All rights reserved.

//Redistribution and use in source and binary forms, with or without
//modification, are permitted provided that the following conditions
//are met:

// * Redistributions of source code must retain the above copyright
//   notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above
//   copyright notice, this list of conditions and the following
//   disclaimer in the documentation and/or other materials provided
//   with the distribution.
// * Neither the name of the Willow Garage nor the names of its
//   contributors may be used to endorse or promote products derived
//   from this software without specific prior written permission.

//THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
//"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
//LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
//FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
//COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
//BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
//LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
//CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
//LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
//ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//POSSIBILITY OF SUCH DAMAGE.

#ifndef LIBTF_HH
#define LIBTF_HH
#include <iostream>
#include <iomanip>
#include <newmat10/newmat.h>
#include <newmat10/newmatio.h>
#include <cmath>
#include <vector>
#include <sstream>

#include "libTF/Pose3DCache.h"

/** \mainpage libTF a transformation library
 *
 * This is a library for keeping track of transforms for 
 * an entire system.
 * 
 * The project page for this can be found <a href="http://pr.willowgarage.com/wiki/Transformations"> here.</a>
 * The most recent manual is in it's source latex in libTF/doc.  It will be 
 * generated by calling make in that directory.  
 *
 * To use libTF on its own the main way to interact with libTF is through the class libTF::TransformReference
 * This class provides both mutators to add data as well as accessors to get data.  
 *
 * For use within a ROS framework using the rosTF wrapper is suggested.  

 *\section overview Overview
 *libTF is designed to provide a simple interface for keeping track 
 *of coordinate transforms within a robotic framework.  
 *A simple case which was one of the driving design considerations was
 *the use of a sensor on an actuated platform.  In this case the sensor
 *will report data in the frame of the moving platform, but the data is much 
 *more useful in the world frame. To provide the transform libTF will be told 
 *the position of the platform periodically as it moves.  And when prompted libTF can 
 *provide the transform from the sensor frame to the world frame at the time when the
 *sensor data was acquired.  Not only will libTF will keep track of the transform between 
 *two coordinate frames, but it will also keep track of a whole tree of coordinate frames, 
 *and automatically chain transformations together between any two connected frames.  

 *\section terms Terminology and Conventions
 *\subsection cf Coodinate Frame
 *In this documentation the default 
 *will be a right handed system with X forward, Y left and Z up. 

 * \subsection dh Denavit-Hartenberg Parameters (DH Parameters)
 *DH Parameters are a way to concicely represent a rigid body tranformation in three dimentions.  
 *It has four parameters: length, twist, offset, and angle.  In addition to using the optimal 
 *amount of data to store the transformation, there are also optimized methods of chaining 
 *transformations together.  And lastly the parameters can directly represent rotary and prismatic
 *joints found on robotic arms.  
 *See http://en.wikipedia.org/wiki/Denavit-Hartenberg_Parameters for more details.  

 \todo Reproduce labeled diagram a good example http://uwf.edu/ria/robotics/robotdraw/DH_parm.htm

\subsection ea Euler Angles
For this library Euler angles are considered to be translations in x, y, z, followed by a rotation around z, y, x.
With the respective angular changes referred to as yaw, pitch and roll. 

\subsection Homogeneous Transformation Matrix
Homogeneous Transformation Matrices are a simple way to manipulate 3D translations and rotations 
with standard matrix multiplication.  It is a composite of a standard 3x3 rotation matrix
(see http://en.wikipedia.org/wiki/Rotation_matrix) and a translation vector.  

Let \f$_1R_0\f$ be the 3x3 rotation matrix defined by the Euler angles \f$(yaw_0,pitch_0,roll_0)\f$ 
and let \f$_1T_0\f$ be the column vector \f$(x_0,y_0,z_0)^T\f$ representing the translation.  The combination 
of these two transformations results in the transformation of reference frame 0 to reference frame 1.

A point P in frame 1, \f$P_1\f$, can be transformed into frame 1, \f$P_0\f$, by the following:

\f[
\left(
\begin{array}{ccc}
P_0 \\
1
\end{array}
\right)
=
\left(\begin{array}{ccc}
_0R_1 & _0T_1 \\
1 & 1
\end{array}
\right)\left(
\begin{array}{ccc}
P_1 \\
1
\end{array}\right)
\f]


The net result is a 4x4 transformation matrix which does both the rotation and translation 
between coordinate frames. The basic approach is to use a 4x1 vector consisting of \f$(x,y,z,1)^T_1\f$ 
and by left multiplying by \f$_0A_1\f$ it will result in \f$(x',y',z',1)^T_1\f$.

The matrix library used within this library is Newmat10.


\subsection newmat Newmat10
Newmat10 is the matrix library used in this library.  Documentation for Newmat can be found at 
http://www.robertnz.net/nm10.htm.  

\subsection popint Point
Within this documentation a point is considered a 3D representation of a position within a 
frame.  It is notated, as x, y, z.  

\subsection time Time Representation
libTF uses an \e unsigned \e long \e long (equivilant to a \e uint64_t to represent nanoseconds since the epoch(1970).  
It is named libTF::ULLtime for clarity.

rosTF converts automatically to the above representation from a time pair of seconds and nanoseconds since the epoch, to 
be consistant with the rest of ROS.  

\subsection vector Vector
Within this library a vector is a representation of a direction.  It is represented with the components in 3 directions, 
x,y,z.  However when subject to transformation, a vector will only be subject to rotations and will remain attached to the 
origin.  For example a point (1,1,1) subject to a translation of 5 in the x direction and yawed by 90 degrees would end
at (5,1,1), while a vector (1,1,1) subject to the same transformation would be (-1,1,1).  

\subsection data Data Types

\section internalmath Summary of Internal Mathematics
This libarary uses quaternion notation as the internal representation
of coordinate transforms.  Transform information is stored in a linked 
list sorted by time.  When a transform is requested the closest two points 
on the linked list are found and then interpolated in time to generate the 
return value.  

\subsection Storage 
The internal storage for the transforms is in quaternion notation.  The data structure is libTF::Pose3D

\subsection Interpolation 
The interpolation method used in this library is Spherical Linear Interpolation
(SLERP). \b SLERP The standard formula for SLERP is defined below.
The inputs are points \f$p_0\f$ and \f$p_1\f$, and \f$t\f$ is the proportion to interpolate 
between \f$p_0\f$ and \f$p_1\f$, and \f$\Omega\f$ is the angle between the axis of the two quaternions. 

\f[
Slerp(p_0,p_1;t) = \frac{sin((1-t)\Omega)}{sin(\Omega)} * p_0 + \frac{sin(t*\Omega)}{sin(\Omega)} * p_1
\f]


\todo add graphic

\subsubsection  Alternatives
The SLERP technique was developed in 1985 by Ken Shoemake. http://graphics.ucmerced.edu/~mkallmann/courses/papers/Shoemake-quattut.pdf
SLERP has been 
largely adopted in the field of computer graphics, however there have been many alternatives 
developed.  The advantages of SLERP are that it provides a constant speed solution 
along the shortest path over the 4D unit sphere.  This is not optimal in all cases however.
A good discussion of various alternatives is here http://number-none.com/product/Understanding%20Slerp,%20Then%20Not%20Using%20It/index.html 
The approaches discussed above are normalized linear interpolation (nlerp), and 
log-quaternion linear interpolation (log-quaternion lerp). 
SLERP can be recursively called to do a cubic interpolation, called SQUAD for short.  
This is discussed at http://www.sjbrown.co.uk/?article=quaternions.


\subsection  conversions Data Representation Conversion
\todo fill this out
\subsubsection mtoq Matrix to Quaternion
\todo fill this out
\subsubsection qtom Quaternion to Matrix
\todo fill this out
\subsubsection dhtom DH Parameters to Matrix
\todo fill this out
\subsubsection etom Euler Angles to Matrix
\todo fill this out
 */



namespace libTF
{

/** ** Point ****
 *  \brief A simple point class incorperating the time and frameID
 * 
 * This is a point class designed to interact with libTF.  It 
 * incorperates the timestamp and associated frame to make 
 * association easier for the programmer.    
 */
 struct TFPoint 
{
  double x,y,z;
  unsigned long long time;
  unsigned int frame;
 };

/** ** Point2D ****
 *  \brief A simple point class incorperating the time and frameID
 * 
 * This is a point class designed to interact with libTF.  It 
 * incorperates the timestamp and associated frame to make 
 * association easier for the programmer.    
 */
struct TFPoint2D
{
  double x,y;
  unsigned long long time;
  unsigned int frame;
};


/** TFVector
 *  \brief A representation of a vector
 */
struct TFVector
{
  double x,y,z;
  unsigned long long time;
  unsigned int frame;
};

/** TFVector2D
 *  \brief A representation of a 2D vector
 * 
 */
struct TFVector2D
{
  double x,y;
  unsigned long long time;
  unsigned int frame;
};

/** TFEulerYPR
 * \brief A representation of Euler angles
 * Using Yaw, Pitch, Roll
 * commonly known as xyz Euler angles */
struct TFEulerYPR
{
  double yaw, pitch, roll;
  unsigned long long time;
  unsigned int frame;
};

/** TFYaw
 * \brief Rotation about the Z axis.  
 */
struct TFYaw
{
  double yaw;
  unsigned long long time;
  unsigned int frame;
};

/** TFPose
 *  \brief A representation of position in free space
 */
struct TFPose
{
  double x,y,z,yaw,pitch,roll;
  unsigned long long time;
  unsigned int frame;
};

/** TFPose2D
 *  \brief A representation of 2D position
 */
struct TFPose2D
{
  double x,y,yaw;
  unsigned long long time;
  unsigned int frame;
};


/** \brief A Class which provides coordinate transforms between any two frames in a system. 
 * 
 * This class provides a simple interface to allow recording and lookup of 
 * relationships between arbitrary frames of the system.
 * 
 * libTF assumes that there is a tree of coordinate frame transforms which define the relationship between all coordinate frames.  
 * For example your typical robot would have a transform from global to real world.  And then from base to hand, and from base to head.  
 * But Base to Hand really is composed of base to shoulder to elbow to wrist to hand.  
 * libTF is designed to take care of all the intermediate steps for you.  
 * 
 * Internal Representation 
 * libTF will store frames with the parameters necessary for generating the transform into that frame from it's parent and a reference to the parent frame.
 * Frames are designated using an unsigned int
 * 0 is a frame without a parent (the top of a tree)
 * The positions of frames over time must be pushed in.  
 * 
 * All function calls which pass frame ids can potentially throw the exception TransformReference::LookupException
 */

class TransformReference
{
public:
  /// All time within libTF is this format.
  typedef unsigned long long ULLtime;
  
  /************* Constants ***********************/
  static const unsigned int NO_PARENT = 0;  //!< The value indicating no parent frame (The top of a tree)
  static const unsigned int MAX_NUM_FRAMES = 10000; //!< The max value of frameID (due to preallocation of pointers)
  static const unsigned int MAX_GRAPH_DEPTH = 100;   //!< The maximum number of time to recurse before assuming the tree has a loop.
  static const ULLtime DEFAULT_CACHE_TIME = 10 * 1000000000ULL;  //!< The default amount of time to cache data
  static const ULLtime DEFAULT_MAX_EXTRAPOLATION_DISTANCE = 10 * 1000000000ULL; //!< The default amount of time to extrapolate


  /** Constructor 
   * \param interpolating Whether to interpolate, if this is false the closest value will be returned
   * \param cache_time How long to keep a history of transforms in nanoseconds
   * \param max_extrapolation_distance How far to extrapolate before throwing an exception
   */
  TransformReference(bool interpolating = true, 
                     ULLtime cache_time = DEFAULT_CACHE_TIME,
                     unsigned long long max_extrapolation_distance = DEFAULT_MAX_EXTRAPOLATION_DISTANCE);
  ~TransformReference();

  /********** Mutators **************/
  /** \brief Add a new frame and parent
   * The frame transformatiosn are left unspecified.
   * \param frameid The id of a frame to add
   * \param parentid The id of the parent frame to the one being added
   *
   *  Possible exceptions are: TransformReference::InvaildFrame
   */
  void addFrame(unsigned int frameid, unsigned int parentid);

  /** \brief Set a new frame or update an old one.
   * \param frameid The destination frame
   * \param parentid The frame id of the parent frame.  
   * \param x Translation forward
   * \param y Translation left
   * \param z Translation up
   * \param yaw Rotation about Z
   * \param pitch Rotation about Y
   * \param roll Rotation about X
   * \param time The tiem at which to set the transform
   *
   * These euler angles are applied in the order top to bottom to the parent coordinate frame to 
   * transform it to the coordinate frame, frameid.  
   * 
   *  Possible exceptions are: TransformReference::LookupException
   */
  void setWithEulers(unsigned int frameid, unsigned int parentid, double x, double y, double z, double yaw, double pitch, double roll, ULLtime time);

  /** \brief Set a transform using DH Parameters 
   * Conventions from http://en.wikipedia.org/wiki/Robotics_conventions 
   *  Possible exceptions are: TransformReference::LookupException
   */
  void setWithDH(unsigned int frameid, unsigned int parentid, double length, double alpha, double offset, double theta, ULLtime time);

  /** \brief Set the transform using a matrix 
   *  Possible exceptions are: TransformReference::LookupException
   */
  void setWithMatrix(unsigned int frameid, unsigned int parentid, const NEWMAT::Matrix & matrix_in, ULLtime time);
  /** \brief Set the transform using quaternions natively 
   *  Possible exceptions are: TransformReference::LookupException
   */
  void setWithQuaternion(unsigned int frameid, unsigned int parentid, double xt, double yt, double zt, double xr, double yr, double zr, double w, ULLtime time);
  

  /*********** Accessors *************/

  /** \brief Get the transform between two frames by frame ID.  
   * \param target_frame The frame to which data should be transformed
   * \param source_frame The frame where the data originated
   * \param time The time at which the value of the transform is desired. (0 will get the latest)
   * 
   * Possible exceptions TransformReference::LookupException, TransformReference::ConnectivityException, 
   * TransformReference::MaxDepthException
   */
  NEWMAT::Matrix getMatrix(unsigned int target_frame, unsigned int source_frame, ULLtime time);


  /** \brief Transform a point to a different frame */
  TFPoint transformPoint(unsigned int target_frame, const TFPoint & point_in);
  /** \brief Transform a 2D point to a different frame */
  TFPoint2D transformPoint2D(unsigned int target_frame, const TFPoint2D & point_in);
  /** \brief Transform a vector to a different frame */
  TFVector transformVector(unsigned int target_frame, const TFVector & vector_in);
  /** \brief Transform a 2D vector to a different frame */
  TFVector2D transformVector2D(unsigned int target_frame, const TFVector2D & vector_in);
  /** \brief Transform Euler angles between frames */
  TFEulerYPR transformEulerYPR(unsigned int target_frame, const TFEulerYPR & euler_in);
  /** \brief Transform Yaw between frames. Useful for 2D navigation */
  TFYaw transformYaw(unsigned int target_frame, const TFYaw & euler_in);
  /** \brief Transform a 6DOF pose.  (x, y, z, yaw, pitch, roll). */
  TFPose transformPose(unsigned int target_frame, const TFPose & pose_in);
  /** \brief Transform a planar pose, x,y,yaw */
  TFPose2D transformPose2D(unsigned int target_frame, const TFPose2D & pose_in);

  /** \brief Debugging function that will print the spanning chain of transforms.
   * Possible exceptions TransformReference::LookupException, TransformReference::ConnectivityException, 
   * TransformReference::MaxDepthException
   */
  std::string viewChain(unsigned int target_frame, unsigned int source_frame);


  /************ Possible Exceptions ****************************/

  /** \brief An exception class to notify of bad frame number 
   * 
   * This is an exception class to be thrown in the case that 
   * a frame not in the graph has been attempted to be accessed.
   * The most common reason for this is that the frame is not
   * being published, or a parent frame was not set correctly 
   * causing the tree to be broken.  
   */
  class LookupException : public std::exception
  {
  public:
    virtual const char* what() const throw()    { return "InvalidFrame"; }
  } InvalidFrame;

  /** \brief An exception class to notify of no connection
   * 
   * This is an exception class to be thrown in the case 
   * that the Reference Frame tree is not connected between
   * the frames requested. */
  class ConnectivityException : public std::exception
  {
  public:
    virtual const char* what() const throw()    { return "No connection between frames"; }
  private:
  } NoFrameConnectivity;

  /** \brief An exception class to notify that the search for connectivity descended too deep. 
   * 
   * This is an exception class which will be thrown if the tree search 
   * recurses too many times.  This is to prevent the search from 
   * infinitely looping in the case that a tree was malformed and 
   * became cyclic.
   */
  class MaxDepthException : public std::exception
  {
  public:
    virtual const char* what() const throw()    { return "Search exceeded max depth.  Probably a loop in the tree."; }
  private:
  } MaxSearchDepth;


private:

  /** \brief The internal storage class for ReferenceTransform.  
   * 
   * An instance of this class is created for each frame in the system.
   * This class natively handles the relationship between frames.  
   *
   * The derived class Pose3DCache provides a buffered history of positions
   * with interpolation.
   * 
   */
  
  class RefFrame: public Pose3DCache 
    {
    public:

      /** Constructor */
      RefFrame(bool interpolating = true,  
               unsigned long long  max_cache_time = DEFAULT_MAX_STORAGE_TIME,
               unsigned long long  max_extrapolation_time = DEFAULT_MAX_EXTRAPOLATION_TIME); 
      
      /** \brief Get the parent nodeID */
      inline unsigned int getParent(){return parent;};
      
      /** \brief Set the parent node 
       * return: false => change of parent, cleared history
       * return: true => no change of parent 
       * \param parentID The frameID of the parent
       */
      bool setParent(unsigned int parentID);

    private:
      
      /** Internal storage of the parent */
      unsigned int parent;

    };

  /******************** Internal Storage ****************/

  /** \brief The pointers to potential frames that the tree can be made of.
   * The frames will be dynamically allocated at run time when set the first time. */
  RefFrame** frames;

  /// How long to cache transform history
  ULLtime cache_time;

  /// whether or not to interpolate or extrapolate
  bool interpolating;
  
  /// whether or not to allow extrapolation
  unsigned long long max_extrapolation_distance;

 public:
  /** \brief An internal representation of transform chains
   * 
   * This struct is how the list of transforms are stored before being passed to computeTransformFromList. */
  typedef struct 
  {
    std::vector<unsigned int> inverseTransforms;
    std::vector<unsigned int> forwardTransforms;
  } TransformLists;

 private: 
  /************************* Internal Functions ****************************/
  
  /** \brief An accessor to get a frame, which will throw an exception if the frame is no there. 
   * \param frame_number The frameID of the desired Reference Frame
   * 
   * This is an internal function which will get the pointer to the frame associated with the frame id
   * Possible Exception: TransformReference::LookupException
   */
  inline RefFrame* getFrame(unsigned int frame_number) { if (frames[frame_number] == NULL) throw InvalidFrame; else return frames[frame_number];};

  /** Find the list of connected frames necessary to connect two different frames */
  TransformLists  lookUpList(unsigned int target_frame, unsigned int source_frame);
  
  /** Compute the transform based on the list of frames */
  NEWMAT::Matrix computeTransformFromList(const TransformLists & list, ULLtime time);

};
}
#endif //LIBTF_HH
